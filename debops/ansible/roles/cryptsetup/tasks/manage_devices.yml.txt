[0].name = Set device list to process to a single device
[0]["ansible.builtin.set_fact"].cryptsetup__process_devices = {{ [cryptsetup__process_device] }}
[0].when = cryptsetup__process_device is defined
[1].name = Assert that device configuration is valid
[1]["ansible.builtin.assert"].that[0] = item.state | d(cryptsetup__state) in ['mounted', 'ansible_controller_mounted', 'unmounted', 'present', 'absent']
[1]["ansible.builtin.assert"].that[1] = item.name is defined and item.name is string
[1]["ansible.builtin.assert"].that[2] = (item.state | d(cryptsetup__state) == 'ansible_controller_mounted' and 'remote_keyfile' not in item) or item.state | d(cryptsetup__state) != 'ansible_controller_mounted'
[1]["ansible.builtin.assert"].that[3] = item.keyfile_gen_type | d(cryptsetup__keyfile_gen_type) in ['binary', 'text']
[1].with_items = {{ cryptsetup__process_devices | d([]) }}
[2].name = Create secrets directory on Ansible controller
[2]["ansible.builtin.file"].path = {{ cryptsetup__secret_path + "/" + item.name }}
[2]["ansible.builtin.file"].state = directory
[2]["ansible.builtin.file"].owner = {{ cryptsetup__secret_owner }}
[2]["ansible.builtin.file"].group = {{ cryptsetup__secret_group }}
[2]["ansible.builtin.file"].mode = {{ cryptsetup__secret_mode }}
[2].become = False
[2].delegate_to = localhost
[2].when = (item.state | d(cryptsetup__state) in ['mounted', 'ansible_controller_mounted', 'unmounted', 'present'] and 'remote_keyfile' not in item)
[2].with_items = {{ cryptsetup__process_devices | d([]) }}
[3].name = Generate binary keyfile on the Ansible controller
[3]["ansible.builtin.shell"] = head -c {{ ((512 / 8) if (item.key_size | d(cryptsetup__key_size) == "default")
                             else ((item.key_size | d(cryptsetup__key_size)) / 8)) | int }} \ {{ cryptsetup__keyfile_source_dev | quote }} > \ {{ (item.keyfile | d(cryptsetup__secret_path + "/" + item.name + "/keyfile.raw")) | quote }}
[3].args.creates = {{ item.keyfile | d(cryptsetup__secret_path + "/" + item.name + "/keyfile.raw") }}
[3].become = False
[3].delegate_to = localhost
[3].register = cryptsetup__register_keyfile_gen
[3].when = (item.state | d(cryptsetup__state) in ['mounted', 'ansible_controller_mounted', 'unmounted', 'present'] and ('remote_keyfile' not in item) and (item.keyfile_gen_type | d(cryptsetup__keyfile_gen_type) == 'binary'))
[3].with_items = {{ cryptsetup__process_devices | d([]) }}
[4].name = Generate text/passphrase keyfile on the Ansible controller
[4]["ansible.builtin.shell"] = set -o nounset -o pipefail -o errexit && {{ item.keyfile_gen_command | d(cryptsetup__keyfile_gen_command) }} \ | tr -d "\n" > {{ (item.keyfile | d(cryptsetup__secret_path + "/" + item.name + "/keyfile.raw")) | quote }}
[4].args.executable = bash
[4].args.creates = {{ item.keyfile | d(cryptsetup__secret_path + "/" + item.name + "/keyfile.raw") }}
[4].become = False
[4].delegate_to = localhost
[4].register = cryptsetup__register_keyfile_gen
[4].when = (item.state | d(cryptsetup__state) in ['mounted', 'ansible_controller_mounted', 'unmounted', 'present'] and ('remote_keyfile' not in item) and (item.keyfile_gen_type | d(cryptsetup__keyfile_gen_type) == 'text'))
[4].with_items = {{ cryptsetup__process_devices | d([]) }}
[5].name = Enforce permissions of the keyfile on the Ansible controller
[5].tags[0] = role::cryptsetup:backup
[5]["ansible.builtin.file"].path = {{ item.keyfile | d(cryptsetup__secret_path + "/" + item.name + "/keyfile.raw") }}
[5]["ansible.builtin.file"].owner = {{ cryptsetup__secret_owner }}
[5]["ansible.builtin.file"].group = {{ cryptsetup__secret_group }}
[5]["ansible.builtin.file"].mode = {{ cryptsetup__secret_mode }}
[5].become = False
[5].delegate_to = localhost
[5].when = (item.state | d(cryptsetup__state) in ['mounted', 'ansible_controller_mounted', 'unmounted', 'present'] and not ansible_check_mode and 'remote_keyfile' not in item)
[5].with_items = {{ cryptsetup__process_devices | d([]) }}
[6].name = Copy keyfiles to remote system
[6]["ansible.builtin.copy"].dest = {{ ("/dev/shm"
              if (item.state | d(cryptsetup__state) == "ansible_controller_mounted")
              else cryptsetup__keyfile_remote_location)
              + "/" + item.name + "_keyfile.raw" }}
[6]["ansible.builtin.copy"].backup = {{ item.keyfile_backup | d(omit) }}
[6]["ansible.builtin.copy"].follow = {{ item.keyfile_follow | d(omit) }}
[6]["ansible.builtin.copy"].force = {{ item.keyfile_force | d(omit) }}
[6]["ansible.builtin.copy"].group = {{ item.keyfile_group | d(cryptsetup__keyfile_group) }}
[6]["ansible.builtin.copy"].mode = {{ item.keyfile_mode | d(cryptsetup__keyfile_mode) }}
[6]["ansible.builtin.copy"].owner = {{ item.keyfile_owner | d(cryptsetup__keyfile_owner) }}
[6]["ansible.builtin.copy"].selevel = {{ item.keyfile_selevel | d(omit) }}
[6]["ansible.builtin.copy"].serole = {{ item.keyfile_serole | d(omit) }}
[6]["ansible.builtin.copy"].setype = {{ item.keyfile_setype | d(omit) }}
[6]["ansible.builtin.copy"].seuser = {{ item.keyfile_seuser | d(omit) }}
[6]["ansible.builtin.copy"].src = {{ item.keyfile | d(cryptsetup__secret_path + "/" + item.name + "/keyfile.raw") }}
[6]["ansible.builtin.copy"].validate = {{ item.keyfile_validate | d(omit) }}
[6].when = (item.state | d(cryptsetup__state) in ['mounted', 'ansible_controller_mounted', 'unmounted', 'present'] and not ansible_check_mode and 'remote_keyfile' not in item)
[6].with_items = {{ cryptsetup__process_devices | d([]) }}
[6].no_log = {{ debops__no_log | d(True) }}
[7].name = Check if ciphertext block device exists
[7]["ansible.builtin.stat"].path = {{ item.ciphertext_block_device }}
[7]["ansible.builtin.stat"].get_checksum = False
[7].register = cryptsetup__register_ciphertext_device
[7].when = (item.state | d(cryptsetup__state) in ['mounted', 'ansible_controller_mounted', 'unmounted', 'present'])
[7].with_items = {{ cryptsetup__process_devices | d([]) }}
[7].tags[0] = role::cryptsetup:backup
[8].name = Fail when ciphertext block device does not exist but the state requires for it to exist
[8]["ansible.builtin.fail"].msg = Ciphertext block device {{ item.0.ciphertext_block_device }} does not
exist and state was requested to be {{ item.0.state | d(cryptsetup__state) }}!

[8].when = (item.0.state | d(cryptsetup__state) in ['mounted', 'ansible_controller_mounted', 'unmounted'] and not item.1.stat.exists)
[8].with_together[0] = {{ cryptsetup__process_devices | d([]) }}
[8].with_together[1] = {{ cryptsetup__register_ciphertext_device.results | d([]) }}
[9].name = Fail when ciphertext block device does not exist but the keyfile has changed
[9]["ansible.builtin.fail"].msg = Ciphertext block device {{ item.0.ciphertext_block_device }} does not
exist but the keyfile has just been generated. You will need to make the
block device available during a later Ansible run so that the encryption
and filesystem layer can be setup. You will not see this error on later
runs but that does not mean that the encryption and filesystem setup was
successfully until you make the block device available. See documentation
for details.

[9].when = (item.0.state | d(cryptsetup__state) in ['mounted', 'ansible_controller_mounted', 'unmounted', 'present'] and not item.1.stat.exists and item.2 is changed)
[9].with_together[0] = {{ cryptsetup__process_devices | d([]) }}
[9].with_together[1] = {{ cryptsetup__register_ciphertext_device.results | d([]) }}
[9].with_together[2] = {{ cryptsetup__register_keyfile_gen.results | d([]) }}
[10].name = Create encryption layer
[10]["ansible.builtin.shell"] = set -o nounset -o pipefail -o errexit && cryptsetup isLuks "{{ item.0.ciphertext_block_device }}" || cryptsetup luksFormat --batch-mode --verbose {{ "" if (item.0.hash | d(cryptsetup__hash) == "default")
               else ("--hash=" + item.0.hash | d(cryptsetup__hash)) }} {{ "" if (item.0.cipher | d(cryptsetup__cipher) == "default")
               else ("--cipher=" + item.0.cipher | d(cryptsetup__cipher)) }} {{ "" if (item.0.key_size | d(cryptsetup__key_size) == "default")
               else ("--key-size=" + item.0.key_size | d(cryptsetup__key_size) | string) }} {{ "" if (item.0.iter_time | d(cryptsetup__iter_time) == "default")
               else ("--iter-time=" + item.0.iter_time | d(cryptsetup__iter_time) | string) }} {% if cryptsetup__use_dev_random | d("default") != "default" %} {{ "--use-random" if cryptsetup__use_dev_random else "--use-urandom" }} {% endif %} --key-file '{{ item.0.remote_keyfile | d(("/dev/shm"
                        if (item.0.state | d(cryptsetup__state) == "ansible_controller_mounted")
                        else cryptsetup__keyfile_remote_location)
                        + "/" + item.0.name + "_keyfile.raw") }}' '{{ item.0.ciphertext_block_device }}'
[10].args.executable = bash
[10].register = cryptsetup__register_cmd
[10].changed_when = ("Command successful." == cryptsetup__register_cmd.stdout)
[10].when = (item.0.state | d(cryptsetup__state) in ['mounted', 'ansible_controller_mounted', 'unmounted', 'present'] and item.1.stat.exists and item.0.mode | d("luks") == "luks")
[10].with_together[0] = {{ cryptsetup__process_devices | d([]) }}
[10].with_together[1] = {{ cryptsetup__register_ciphertext_device.results | d([]) }}
[11].name = Get UUID for ciphertext block device
[11]["ansible.builtin.command"] = blkid -s UUID -o value "{{ item.0.ciphertext_block_device }}"
[11].register = cryptsetup__register_ciphertext_blkid
[11].changed_when = False
[11].failed_when = (cryptsetup__register_ciphertext_blkid.rc not in [0, 2])
[11].check_mode = False
[11].when = (item.0.state | d(cryptsetup__state) in ['mounted', 'ansible_controller_mounted', 'unmounted', 'present'] and item.1.stat.exists)
[11].with_together[0] = {{ cryptsetup__process_devices | d([]) }}
[11].with_together[1] = {{ cryptsetup__register_ciphertext_device.results | d([]) }}
[12].name = Ensure ciphertext block device is configured in crypttab
[12]["community.general.crypttab"].backing_device = {{ ("UUID=" + item.1.stdout)
                        if (item.1.stdout | d() and item.0.use_uuid | d(cryptsetup__use_uuid) | bool)
                        else item.0.ciphertext_block_device }}
[12]["community.general.crypttab"].name = {{ item.0.name }}
[12]["community.general.crypttab"].opts = {{ (item.2.crypttab_options | d(cryptsetup__crypttab_options | d([])) | list | sort | unique | join(","))
              if ((item.2.crypttab_options | d(cryptsetup__crypttab_options | d([])) | list | length) > 0)
              else "none" }}
[12]["community.general.crypttab"].password = {{ item.0.remote_keyfile | d(("/dev/shm"
                  if (item.0.state | d(cryptsetup__state) == "ansible_controller_mounted")
                  else cryptsetup__keyfile_remote_location)
                  + "/" + item.0.name + "_keyfile.raw") }}
[12]["community.general.crypttab"].path = {{ item.0.crypttab_path | d(omit) }}
[12]["community.general.crypttab"].state = present
[12].no_log = {{ debops__no_log | d(True) }}
[12].when = (item.0.state | d(cryptsetup__state) in ['mounted', 'ansible_controller_mounted', 'unmounted', 'present'])
[12].with_together[0] = {{ cryptsetup__process_devices | d([]) }}
[12].with_together[1] = {{ cryptsetup__register_ciphertext_blkid.results | d([]) }}
[12].with_together[2] = {{ lookup("template", "lookup/cryptsetup__devices_crypttab_options.j2") | from_yaml }}
[13].name = Start plaintext device mapper target
[13]["ansible.builtin.command"] = cryptdisks_start "{{ item.0.name }}"
[13].register = cryptsetup__register_cryptdisks_start
[13].changed_when = ("(started)" in cryptsetup__register_cryptdisks_start.stdout)
[13].when = (item.0.state | d(cryptsetup__state) in ['mounted', 'ansible_controller_mounted', 'unmounted', 'present'] and item.1.stat.exists)
[13].with_together[0] = {{ cryptsetup__process_devices | d([]) }}
[13].with_together[1] = {{ cryptsetup__register_ciphertext_device.results | d([]) }}
[14].name = Check if plaintext device mapper target exists
[14]["ansible.builtin.stat"].path = /dev/mapper/{{ item.name }}
[14].register = cryptsetup__register_plaintext_device
[14].when = (item.state | d(cryptsetup__state) in ['mounted', 'ansible_controller_mounted', 'unmounted', 'present'] and (item.manage_filesystem | d(True) | bool))
[14].with_items = {{ cryptsetup__process_devices | d([]) }}
[15].name = Create filesystem on plaintext device mapper target
[15]["community.general.filesystem"].dev = /dev/mapper/{{ item.0.name }}
[15]["community.general.filesystem"].force = {{ item.0.format_force | d(omit) }}
[15]["community.general.filesystem"].fstype = {{ item.0.fstype | d(cryptsetup__fstype) }}
[15]["community.general.filesystem"].opts = {{ item.0.format_options | d(omit) }}
[15].when = (item.1 | d() and item.1.stat | d() and item.1.stat.exists | d() and (item.0.create_filesystem | d(item.0.manage_filesystem | d(True)) | bool) and not (item.0.swap | d(False) | bool))
[15].with_together[0] = {{ cryptsetup__process_devices | d([]) }}
[15].with_together[1] = {{ cryptsetup__register_plaintext_device.results | d([]) }}
[16].name = Ensure mount directories exist when manually mounted
[16]["ansible.builtin.file"].path = {{ item.mount | d(cryptsetup__mountpoint_parent_directory + "/" + item.name) }}
[16]["ansible.builtin.file"].state = directory
[16]["ansible.builtin.file"].mode = 0755
[16].when = (item.state | d(cryptsetup__state) in ['present'] and (item.manage_filesystem | d(True) | bool))
[16].with_items = {{ cryptsetup__process_devices | d([]) }}
[17].name = Create LUKS header backup
[17].tags[0] = role::cryptsetup:backup
[17]["ansible.builtin.shell"] = set -o nounset -o pipefail -o errexit &&
rm -f {{ (cryptsetup__header_backup_remote_location + "/" + item.0.name + "_header_backup.raw") | quote }}
cryptsetup luksHeaderBackup {{ item.0.ciphertext_block_device | quote }} \
  --header-backup-file {{ (cryptsetup__header_backup_remote_location + "/"
                           + item.0.name + "_header_backup.raw") | quote }}

[17].args.executable = bash
[17].changed_when = False
[17].when = ((item.0.backup_header | d(cryptsetup__header_backup) | bool) and item.0.state | d(cryptsetup__state) in ['mounted', 'ansible_controller_mounted', 'unmounted', 'present'] and item.1.stat.exists and item.0.mode | d("luks") == "luks")
[17].with_together[0] = {{ cryptsetup__process_devices | d([]) }}
[17].with_together[1] = {{ cryptsetup__register_ciphertext_device.results | d([]) }}
[18].name = Store the header backup in secret directory on to the Ansible controller
[18].tags[0] = role::cryptsetup:backup
[18]["ansible.builtin.fetch"].src = {{ cryptsetup__header_backup_remote_location + "/" + item.0.name + "_header_backup.raw" }}
[18]["ansible.builtin.fetch"].dest = {{ cryptsetup__secret_path + "/" + item.0.name + "/header_backup.raw" }}
[18]["ansible.builtin.fetch"].fail_on_missing = True
[18]["ansible.builtin.fetch"].flat = True
[18].when = ((item.0.backup_header | d(cryptsetup__header_backup) | bool) and item.0.state | d(cryptsetup__state) in ['mounted', 'ansible_controller_mounted', 'unmounted', 'present'] and item.1.stat.exists and item.0.mode | d("luks") == "luks")
[18].with_together[0] = {{ cryptsetup__process_devices | d([]) }}
[18].with_together[1] = {{ cryptsetup__register_ciphertext_device.results | d([]) }}
[19].name = Enforce permissions of the header backup on the Ansible controller
[19].tags[0] = role::cryptsetup:backup
[19]["ansible.builtin.file"].path = {{ cryptsetup__secret_path + "/" + item.0.name + "/header_backup.raw" }}
[19]["ansible.builtin.file"].owner = {{ cryptsetup__secret_owner }}
[19]["ansible.builtin.file"].group = {{ cryptsetup__secret_group }}
[19]["ansible.builtin.file"].mode = {{ cryptsetup__secret_mode }}
[19].become = False
[19].delegate_to = localhost
[19].when = ((item.0.backup_header | d(cryptsetup__header_backup) | bool) and item.0.state | d(cryptsetup__state) in ['mounted', 'ansible_controller_mounted', 'unmounted', 'present'] and item.1.stat.exists and item.0.mode | d("luks") == "luks" and not ansible_check_mode)
[19].with_together[0] = {{ cryptsetup__process_devices | d([]) }}
[19].with_together[1] = {{ cryptsetup__register_ciphertext_device.results | d([]) }}
[20].name = Manage fstab and mount state of the plaintext device mapper targets
[20]["ansible.posix.mount"].src = /dev/mapper/{{ item.name }}
[20]["ansible.posix.mount"].fstype = {{ item.fstype | d(cryptsetup__fstype) }}
[20]["ansible.posix.mount"].name = {{ item.mount | d(cryptsetup__mountpoint_parent_directory + "/" + item.name) }}
[20]["ansible.posix.mount"].opts = {{ (item.mount_options | d(cryptsetup__mount_options | d([]))) | list | sort | unique | join(",") }}
[20]["ansible.posix.mount"].dump = {{ item.mount_dump | d(omit) }}
[20]["ansible.posix.mount"].passno = {{ item.mount_passno | d(omit) }}
[20]["ansible.posix.mount"].fstab = {{ item.fstab_path | d(cryptsetup__fstab_file) }}
[20]["ansible.posix.mount"].state = {{ "mounted"
                if (item.state | d(cryptsetup__state) == "ansible_controller_mounted")
                else item.state | d(cryptsetup__state) }}
[20].when = ((item.manage_filesystem | d(True) | bool) and not (item.swap | d(False) | bool))
[20].with_items = {{ cryptsetup__process_devices | d([]) }}
[21].name = Disable swap devices when requested
[21]["ansible.builtin.shell"] = if [ -e {{ ("/dev/mapper/" + item.name) | quote }} ]
then swapoff {{ ("/dev/mapper/" + item.name) | quote }}
else true
fi

[21].changed_when = False
[21].when = ((item.swap | d(False) | bool) and (item.state | d(cryptsetup__state) in ["unmounted", "absent"]))
[21].with_items = {{ cryptsetup__process_devices | d([]) }}
[22].name = Manage swap devices in fstab
[22]["ansible.posix.mount"].src = {{ "/dev/mapper/" + item.name }}
[22]["ansible.posix.mount"].name = none
[22]["ansible.posix.mount"].fstype = swap
[22]["ansible.posix.mount"].opts = {{ ((item.swap_options | d([]) | list) +
                 (["pri=" + (item.priority | d(cryptsetup__swap_priority) | string)]))
                | list | sort | unique | join(",") }}
[22]["ansible.posix.mount"].dump = 0
[22]["ansible.posix.mount"].passno = 0
[22]["ansible.posix.mount"].fstab = {{ item.fstab_path | d(cryptsetup__fstab_file) }}
[22]["ansible.posix.mount"].state = {{ (item.state | d(cryptsetup__state) == "absent") | ternary("absent", "present") }}
[22].register = cryptsetup__register_swap_fstab
[22].when = item.swap | d(False) | bool
[22].with_items = {{ cryptsetup__process_devices | d([]) }}
[23].name = Enable swap devices
[23]["ansible.builtin.command"] = swapon --priority {{ (item.item.priority | d(cryptsetup__swap_priority) | string) | quote }} {{ ("/dev/mapper/" + item.item.name) | quote }}
[23].register = cryptsetup__register_swapon
[23].changed_when = cryptsetup__register_swapon.changed | bool
[23].when = (item is changed and (item.item.swap | d(False) | bool) and (item.item.state | d(cryptsetup__state) in ['mounted', 'ansible_controller_mounted']))
[23].with_items = {{ cryptsetup__register_swap_fstab.results | d([]) }}
[24].name = Ensure mount directory is absent
[24]["ansible.builtin.file"].path = {{ item.mount | d(cryptsetup__mountpoint_parent_directory + "/" + item.name) }}
[24]["ansible.builtin.file"].state = absent
[24].when = (item.state | d(cryptsetup__state) in ['absent'])
[24].with_items = {{ cryptsetup__process_devices | d([]) }}
[25].name = Stop plaintext device mapper target
[25]["ansible.builtin.command"] = cryptdisks_stop "{{ item.0.name }}"
[25].register = cryptsetup__register_cryptdisks_stop
[25].changed_when = ("(stopping)" in cryptsetup__register_cryptdisks_stop.stdout)
[25].failed_when = (cryptsetup__register_cryptdisks_stop.rc != 0 and not (('Stopping crypto disk...' == cryptsetup__register_cryptdisks_stop.stdout or 'failed, not found in crypttab' in cryptsetup__register_cryptdisks_stop.stdout) and cryptsetup__register_cryptdisks_stop.rc == 1))
[25].when = (item.0.state | d(cryptsetup__state) in ['unmounted', 'absent'] or (item.0.state | d(cryptsetup__state) in ['present'] and item.1 is changed))
[25].with_together[0] = {{ cryptsetup__process_devices | d([]) }}
[25].with_together[1] = {{ cryptsetup__register_cryptdisks_start.results | d([]) }}
[26].name = Ensure ciphertext block device is absent in crypttab
[26]["community.general.crypttab"].name = {{ item.name }}
[26]["community.general.crypttab"].path = {{ item.crypttab_path | d(omit) }}
[26]["community.general.crypttab"].state = absent
[26].when = (item.state | d(cryptsetup__state) in ['absent'])
[26].with_items = {{ cryptsetup__process_devices | d([]) }}
[27].name = Check if remote keyfiles are regular files
[27]["ansible.builtin.stat"].path = {{ (item.remote_keyfile | d(("/dev/shm"
               if (item.state | d(cryptsetup__state) == "ansible_controller_mounted")
               else cryptsetup__keyfile_remote_location)
               + "/" + item.name + "_keyfile.raw")) }}
[27].register = cryptsetup__register_stat_remote_keyfile
[27].when = (item.state | d(cryptsetup__state) in ['ansible_controller_mounted', 'absent'])
[27].with_items = {{ cryptsetup__process_devices | d([]) }}
[28].name = Ensure keyfile is unaccessible on the remote system
[28]["ansible.builtin.command"] = {{ cryptsetup__keyfile_shred_command }} {{ item.stat.path | quote }}
[28].args.removes = {{ item.stat.path }}
[28].when = (item.item.state | d(cryptsetup__state) in ['ansible_controller_mounted', 'absent'] and item.stat.exists and item.stat.isreg)
[28].with_items = {{ cryptsetup__register_stat_remote_keyfile.results | d([]) }}
[29].name = Ensure header backup is unaccessible on the remote system
[29]["ansible.builtin.command"] = {{ cryptsetup__header_backup_shred_command }} {{ cryptsetup__header_backup_remote_location + "/" + item.name + "_header_backup.raw" | quote }}
[29].args.removes = {{ cryptsetup__header_backup_remote_location + "/" + item.name + "_header_backup.raw" }}
[29].when = ((item.state | d(cryptsetup__state) == 'absent' or not (item.backup_header | d(cryptsetup__header_backup) | bool)) and 'remote_keyfile' not in item)
[29].with_items = {{ cryptsetup__process_devices | d([]) }}
[29].tags[0] = role::cryptsetup:backup
