~d0.hosts = localhost
~d1.gather_facts = false
~d1.connection = local
~d1.name = Update source tree if necessary
~d1.tasks = 
~d2.name = Delete project directory before update
~d3.ansible.builtin.shell = set -o pipefail && find . -delete -print | tail -2  # volume mounted, cannot delete folder itself
~d3.register = reg
~d3.changed_when = reg.stdout_lines | length > 1
~d3.args = 
~d4.chdir = "{{ project_path }}"
~d3.tags = 
~d2.name = Update project using git
~d3.tags = 
~d3.block = 
~d4.name = Update project using git
~d5.ansible.builtin.git = 
~d6.dest = "{{ project_path | quote }}"
~d6.repo = "{{ scm_url }}"
~d6.version = "{{ scm_branch | quote }}"
~d6.refspec = "{{ scm_refspec | default(omit) }}"
~d6.force = "{{ scm_clean }}"
~d6.track_submodules = "{{ scm_track_submodules | default(omit) }}"
~d6.accept_hostkey = "{{ scm_accept_hostkey | default(omit) }}"
~d5.register = git_result
~d4.name = Set the git repository version
~d5.ansible.builtin.set_fact = 
~d6.scm_version = "{{ git_result['after'] }}"
~d5.when = "'after' in git_result"
~d2.name = Update project using svn
~d3.tags = 
~d3.block = 
~d4.name = Update project using svn
~d5.ansible.builtin.subversion = 
~d6.dest = "{{ project_path | quote }}"
~d6.repo = "{{ scm_url | quote }}"
~d6.revision = "{{ scm_branch | quote }}"
~d6.force = "{{ scm_clean }}"
~d6.username = "{{ scm_username | default(omit) }}"
~d6.password = "{{ scm_password | default(omit) }}"
~d6.in_place = true
~d5.environment = 
~d6.LC_ALL = 'en_US.UTF-8'
~d5.register = svn_result
~d4.name = Set the svn repository version
~d5.ansible.builtin.set_fact = 
~d6.scm_version = "{{ svn_result['after'] }}"
~d5.when = "'after' in svn_result"
~d4.name = Parse subversion version string properly
~d5.ansible.builtin.set_fact = 
~d6.scm_version = "{{ scm_version | regex_replace('^.*Revision: ([0-9]+).*$', '\\1') }}"
~d2.name = Project update for Insights
~d3.tags = 
~d3.block = 
~d4.name = Ensure the project directory is present
~d5.ansible.builtin.file = 
~d6.dest = "{{ project_path | quote }}"
~d6.state = directory
~d6.mode = '0755'
~d4.name = Fetch Insights Playbook(s)
~d5.insights = 
~d6.insights_url = "{{ insights_url }}"
~d6.username = "{{ scm_username | default(omit) }}"
~d6.password = "{{ scm_password | default(omit) }}"
~d6.project_path = "{{ project_path }}"
~d6.awx_license_type = "{{ awx_license_type }}"
~d6.awx_version = "{{ awx_version }}"
~d6.client_id = "{{ client_id | default(omit) }}"
~d6.client_secret = "{{ client_secret | default(omit) }}"
~d6.authentication = "{{ authentication | default(omit) }}"
~d5.register = results
~d4.name = Save Insights Version
~d5.ansible.builtin.set_fact = 
~d6.scm_version = "{{ results.version }}"
~d5.when = results is defined
~d2.name = Update project using archive
~d3.tags = 
~d3.block = 
~d4.name = Ensure the project archive directory is present
~d5.ansible.builtin.file = 
~d6.dest = "{{ project_path | quote }}/.archive"
~d6.state = directory
~d6.mode = '0755'
~d4.name = Get archive from url
~d5.ansible.builtin.get_url = 
~d6.url = "{{ scm_url | quote }}"
~d6.dest = "{{ project_path | quote }}/.archive/"
~d6.url_username = "{{ scm_username | default(omit) }}"
~d6.url_password = "{{ scm_password | default(omit) }}"
~d6.force_basic_auth = true
~d6.mode = '0755'
~d5.register = get_archive
~d4.name = Unpack archive
~d5.project_archive = 
~d6.src = "{{ get_archive.dest }}"
~d6.project_path = "{{ project_path | quote }}"
~d6.force = "{{ scm_clean }}"
~d5.when = get_archive.changed or scm_clean
~d5.register = unarchived
~d4.name = Find previous archives
~d5.ansible.builtin.find = 
~d6.paths = "{{ project_path | quote }}/.archive/"
~d6.excludes = 
~d5.when = unarchived.changed
~d5.register = previous_archive
~d4.name = Remove previous archives
~d5.ansible.builtin.file = 
~d6.path = "{{ item.path }}"
~d6.state = absent
~d5.loop = "{{ previous_archive.files }}"
~d5.when = previous_archive.files | default([])
~d4.name = Set scm_version to archive sha1 checksum
~d5.ansible.builtin.set_fact = 
~d6.scm_version = "{{ get_archive.checksum_src }}"
~d2.name = Repository Version
~d3.ansible.builtin.debug = 
~d4.msg = "Repository Version {{ scm_version }}"
~d3.tags = 
~d0.hosts = localhost
~d1.gather_facts = false
~d1.connection = local
~d1.name = Perform project signature/checksum verification
~d1.tasks = 
~d2.name = Verify project content using GPG signature
~d3.verify_project = 
~d4.project_path = "{{ project_path | quote }}"
~d4.validation_type = gpg
~d4.gpg_pubkey = "{{ gpg_pubkey }}"
~d3.tags = 
~d2.name = Verify project content against checksum manifest
~d3.verify_project = 
~d4.project_path = "{{ project_path | quote }}"
~d4.validation_type = checksum_manifest
~d3.tags = 
~d0.hosts = localhost
~d1.gather_facts = false
~d1.connection = local
~d1.name = Install content with ansible-galaxy command if necessary
~d1.vars = 
~d2.galaxy_task_env = # configured in settings
~d2.additional_galaxy_env = 
~d3.ANSIBLE_COLLECTIONS_PATH = "{{ projects_root }}/.__awx_cache/{{ local_path }}/stage/requirements_collections"
~d3.ANSIBLE_ROLES_PATH = "{{ projects_root }}/.__awx_cache/{{ local_path }}/stage/requirements_roles"
~d3.ANSIBLE_LOCAL_TEMP = "{{ projects_root }}/.__awx_cache/{{ local_path }}/stage/tmp"
~d1.tasks = 
~d2.name = Check content sync settings
~d3.when = not roles_enabled | bool and not collections_enabled | bool
~d3.tags = 
~d3.block = 
~d4.name = Warn about disabled content sync
~d5.ansible.builtin.debug = 
~d6.msg = >
~d4.name = End play due to disabled content sync
~d5.ansible.builtin.meta = end_play
~d2.block = 
~d4.name = Fetch galaxy roles from roles/requirements.(yml/yaml)
~d5.ansible.builtin.command = 
~d6.cmd = "ansible-galaxy role install -r {{ req_file }} {{ verbosity }}"
~d5.register = galaxy_result
~d5.vars = 
~d6.req_file = "{{ lookup('ansible.builtin.first_found', req_candidates, skip=True) }}"
~d6.req_candidates = 
~d7.files = 
~d7.skip = True
~d5.changed_when = "'was installed successfully' in galaxy_result.stdout"
~d5.when = 
~d5.tags = 
~d4.name = Fetch galaxy collections from collections/requirements.(yml/yaml)
~d5.ansible.builtin.command = 
~d6.cmd = "ansible-galaxy collection install -r {{ req_file }} {{ verbosity }}"
~d5.register = galaxy_collection_result
~d5.vars = 
~d6.req_file = "{{ lookup('ansible.builtin.first_found', req_candidates, skip=True) }}"
~d6.req_candidates = 
~d7.files = 
~d7.skip = True
~d5.changed_when = "'Nothing to do.' not in galaxy_collection_result.stdout"
~d5.when = 
~d5.tags = 
~d4.name = Fetch galaxy roles and collections from requirements.(yml/yaml)
~d5.ansible.builtin.command = 
~d6.cmd = "ansible-galaxy install -r {{ req_file }} {{ verbosity }}"
~d5.register = galaxy_combined_result
~d5.vars = 
~d6.req_file = "{{ lookup('ansible.builtin.first_found', req_candidates, skip=True) }}"
~d6.req_candidates = 
~d7.files = 
~d7.skip = True
~d5.changed_when = "'Nothing to do.' not in galaxy_combined_result.stdout"
~d5.when = 
~d5.tags = 
~d3.module_defaults = 
~d4.ansible.builtin.command = 
~d5.chdir = "{{ project_path | quote }}"
~d3.environment = "{{ galaxy_task_env | combine(additional_galaxy_env) }}"
~d3.vars = 
~d4.verbosity = "{{ (ansible_verbosity) | ternary('-'+'v'*ansible_verbosity, '') }}"
