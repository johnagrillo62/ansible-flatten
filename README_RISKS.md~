
# FINDINGS.md

Security findings from grepping 86,811 flattened paths across 14 public Ansible repos.

Everything below was found with grep on the flattened output. These findings need evaluation. Until now, that evaluation was not possible — the files could not be parsed by any standard tool. These repos are templates, examples, and frameworks used in unknown environments. They may be running in hospitals, utilities, schools, government, or production infrastructure. The risk has never been assessed because the files have never been readable by scanners.

## Summary

| Finding | Count |
|---------|-------|
| Hardcoded passwords (not in variables) | 343 |
| Shell/command/raw calls | 1,389 |
| Shell with Jinja2 (injection surface) | 569 |
| no_log = true (hidden output) | 256 |
| validate_certs = false (TLS disabled) | 34 |
| become/sudo escalation | 142 |
| Hardcoded tokens and secrets | 29 |
| Credentials in URLs | 11 |
| ignore_errors = true | 222 |
| delegate_to localhost | 129 |
| Overly permissive modes (0777/0666) | 3 |

## Hardcoded passwords

Plaintext passwords in public repos. Not in variables. Not in vault.

```
vault_userpass_password = "userpass123"
password = s3cr3t
password = secret
become_password = supersecret
vault_password = secret-vault
authorize_password = authorize-me
password = foobarbaz
```

Some are test fixtures. Whether test fixtures represent risk depends on whether people copy them as templates — which is what test fixtures are for.

## Hardcoded tokens and secrets

```
bearer_token = "asdf1234"
VAULT_DEV_ROOT_TOKEN_ID = 'vaultdev'
secret_key = "my_key"
value.my_key = this_is_the_secret_value
value.my_key = this_is_the_userpass_secret_value
notification_configuration.token = a_token
account_token = a_token
```

## Credentials in URLs

Database passwords, user credentials, embedded in connection strings.

```
db-url=mysql://domain:1234@localhost/domain
mysql+pymysql://mailman3:mmpass@localhost/mailman3
postgres://mailman3:mmpass@localhost/mailman3
mysql://roundcube:pass@localhost/roundcubemail
baseurl=http://se_user:se_pass@enterprise.sensuapp.com/yum/
```

## TLS disabled

Every vault operation in AWX docker-compose runs with `validate_certs = false`. 34 instances across the repos.

```
validate_certs = false
validate_certs = False
ansible_httpapi_validate_certs = False
verify_ssl=false
```

These are the files that configure how secrets are stored and retrieved. The secret manager itself has TLS disabled.

## Shell commands with Jinja2 injection surfaces

569 shell commands with Jinja2 variables interpolated directly into the command string. Every one is an injection surface if the variable contains user-controlled input.

```
command = "{{ galaxy_venv_dir }}/bin/python {{ galaxy_server_dir }}/scripts/manage_db.py -c {{ galaxy_config_file }} upgrade"
shell = "{{ sources_dest }}/minikube start --driver={{ driver }}"
command = openssl genrsa -out {{ work_sign_private_keyfile }} {{ receptor_rsa_bits }}
command = docker login -u="{{ docker_user }}" -p="{{ docker_password }}" "{{ docker_host }}"
```

The last one puts the password on the command line — visible in the process list to anyone on the box.

## no_log hiding output

256 tasks across the repos hide their output from logs. Some legitimate (certificate handling). Some suspicious. No scanner checks what's behind `no_log = true` because no scanner can parse the files.

## SSH security disabled

```
StrictHostKeyChecking=no
UserKnownHostsFile=/dev/null
host_key_checking = false
```

MITM wide open. These are Kubernetes deployment playbooks (kubespray) — the nodes that run your production workloads accept connections from anything that answers.

## SELinux and firewalls disabled

```
preinstall_selinux_state = permissive
name = Ensure firewalld is stopped (since this is a test server).
service = name=firewalld state=stopped
```

Marked as test configuration. Whether these defaults propagate to production deployments is unknown without evaluating downstream usage.

## Unpinned pip installs from public repos

These playbooks run on internal nodes with `become = true` (root). They pull packages from public PyPI with no version pins.

```
pip.name = openshift
pip.name = PyYAML
pip = name=pymongo state=latest
pip.name = gunicorn
pip.name = ndg-httpsclient
pip = name=docker state=present
```

No version pin means whatever is on PyPI right now gets installed as root on your internal node. A supply chain attacker poisons the package, and these playbooks install it automatically.

## Third-party repos over HTTP

Package repositories added over unencrypted HTTP — MITM can inject any package.

```
deb http://download.owncloud.org/download/repositories/stable/Debian_8.0/ /
deb http://www.rabbitmq.com/debian/ testing main
baseurl = http://download.fedoraproject.org/pub/epel/7/$basearch
deb http://ppa.launchpad.net/ansible/ansible/ubuntu xenial main
```

## The full picture on internal nodes

These playbooks are designed to run on internal production nodes. If they do, the combination looks like this:

- Unpinned packages pulled from public PyPI
- Over HTTP in some cases
- With `become = true` — installed as root
- With `ignore_errors = true` — failures silently swallowed
- With `StrictHostKeyChecking=no` — connects to whatever answers
- With `validate_certs = false` — doesn't verify who it's talking to
- With `no_log = true` — hides what it did

Whether this represents actual risk depends on where these playbooks run and how they've been modified. That assessment requires being able to read the files. Which requires being able to parse them.

## What found this

Grep. On flattened YAML.

These findings may or may not represent real risk. The point is that until now, nobody could evaluate them. The files didn't parse. Now they do.

