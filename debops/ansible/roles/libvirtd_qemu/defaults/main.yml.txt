libvirtd_qemu__kvm_support = {{ True
                                if (ansible_virtualization_type == "kvm" and
                                    (ansible_virtualization_role == "host" or
                                     libvirtd_qemu__register_hw_virt.stdout | d()))
                                else False }}
libvirtd_qemu__base_packages[0] = libvirt-daemon-system
libvirtd_qemu__base_packages_map.trusty[0] = libvirt-bin
libvirtd_qemu__base_packages_map.xenial[0] = libvirt-bin
libvirtd_qemu__kvm_packages = {{ ["qemu-system-x86", "qemu-utils"]
                                 + ["qemu-kvm"]
                                   if ansible_distribution_release in
                                        ["stretch", "buster", "bionic", "focal"]
                                   else [] }}
libvirtd_qemu__deployment_mode = {{ ansible_local.libvirtd.deployment_mode
                                    if (ansible_local.libvirtd.deployment_mode | d())
                                    else ("opennebula"
                                          if ("debops_service_opennebula_node" in group_names)
                                          else "libvirt") }}
libvirtd_qemu__user = {{ (ansible_local.opennebula.user
                          if (ansible_local.opennebula.user | d())
                          else "oneadmin")
                         if (libvirtd_qemu__deployment_mode == "opennebula")
                         else "libvirt-qemu" }}
libvirtd_qemu__group = {{ (ansible_local.opennebula.group
                           if (ansible_local.opennebula.group | d())
                           else "oneadmin")
                          if (libvirtd_qemu__deployment_mode == "opennebula")
                          else "libvirt-qemu" }}
libvirtd_qemu__remote_display_ports = {{ libvirtd_qemu__remote_display_port_min | string + ":"
                                         + libvirtd_qemu__remote_display_port_max | string }}
libvirtd_qemu__remote_display_port_min = 5900
libvirtd_qemu__remote_display_port_max = 65535
libvirtd_qemu__spice_listen = {{ "0.0.0.0"
                                 if libvirtd_qemu__remote_display_allow | d()
                                 else "127.0.0.1" }}
libvirtd_qemu__vnc_listen = {{ "0.0.0.0"
                               if libvirtd_qemu__remote_display_allow | d()
                               else "127.0.0.1" }}
libvirtd_qemu__original_configuration[0].name = default_tls_x509_cert_dir
libvirtd_qemu__original_configuration[0].comment = Use of TLS requires that x509 certificates be issued. The default is
to keep them in /etc/pki/qemu. This directory must contain

ca-cert.pem - the CA master certificate
server-cert.pem - the server certificate signed with ca-cert.pem
server-key.pem  - the server private key

and optionally may contain

dh-params.pem - the DH params configuration file

libvirtd_qemu__original_configuration[0].value = /etc/pki/qemu
libvirtd_qemu__original_configuration[0].section = tls
libvirtd_qemu__original_configuration[0].state = comment
libvirtd_qemu__original_configuration[0].weight = 1
libvirtd_qemu__original_configuration[1].name = default_tls_x509_verify
libvirtd_qemu__original_configuration[1].comment = The default TLS configuration only uses certificates for the server
allowing the client to verify the server identity and establish
an encrypted channel.

It is possible to use x509 certificates for authentication too, by
issuing a x509 certificate to every client who needs to connect.

Enabling this option will reject any client who does not have a
certificate signed by the CA in /etc/pki/qemu/ca-cert.pem

libvirtd_qemu__original_configuration[1].value = True
libvirtd_qemu__original_configuration[1].section = tls
libvirtd_qemu__original_configuration[1].state = comment
libvirtd_qemu__original_configuration[1].weight = 2
libvirtd_qemu__original_configuration[2].name = default_tls_x509_secret_uuid
libvirtd_qemu__original_configuration[2].comment = Libvirt assumes the server-key.pem file is unencrypted by default.
To use an encrypted server-key.pem file, the password to decrypt
the PEM file is required. This can be provided by creating a secret
object in libvirt and then to uncomment this setting to set the UUID
of the secret.

NB This default all-zeros UUID will not work. Replace it with the
output from the UUID for the TLS secret from a 'virsh secret-list'
command and then uncomment the entry

libvirtd_qemu__original_configuration[2].value = 00000000-0000-0000-0000-000000000000
libvirtd_qemu__original_configuration[2].section = tls
libvirtd_qemu__original_configuration[2].state = comment
libvirtd_qemu__original_configuration[2].weight = 3
libvirtd_qemu__original_configuration[3].name = vnc_listen
libvirtd_qemu__original_configuration[3].comment = VNC is configured to listen on 127.0.0.1 by default.
To make it listen on all public interfaces, uncomment
this next option.

NB, strong recommendation to enable TLS + x509 certificate
verification when allowing public access

libvirtd_qemu__original_configuration[3].value = 0.0.0.0
libvirtd_qemu__original_configuration[3].section = vnc
libvirtd_qemu__original_configuration[3].state = comment
libvirtd_qemu__original_configuration[3].weight = 1
libvirtd_qemu__original_configuration[4].name = vnc_auto_unix_socket
libvirtd_qemu__original_configuration[4].comment = Enable this option to have VNC served over an automatically created
unix socket. This prevents unprivileged access from users on the
host machine, though most VNC clients do not support it.

This will only be enabled for VNC configurations that have listen
type=address but without any address specified. This setting takes
preference over vnc_listen.

libvirtd_qemu__original_configuration[4].value = True
libvirtd_qemu__original_configuration[4].section = vnc
libvirtd_qemu__original_configuration[4].state = comment
libvirtd_qemu__original_configuration[4].weight = 2
libvirtd_qemu__original_configuration[5].name = vnc_tls
libvirtd_qemu__original_configuration[5].comment = Enable use of TLS encryption on the VNC server. This requires
a VNC client which supports the VeNCrypt protocol extension.
Examples include vinagre, virt-viewer, virt-manager and vencrypt
itself. UltraVNC, RealVNC, TightVNC do not support this

It is necessary to setup CA and issue a server certificate
before enabling this.

libvirtd_qemu__original_configuration[5].value = True
libvirtd_qemu__original_configuration[5].section = vnc
libvirtd_qemu__original_configuration[5].state = comment
libvirtd_qemu__original_configuration[5].weight = 3
libvirtd_qemu__original_configuration[6].name = vnc_tls_x509_cert_dir
libvirtd_qemu__original_configuration[6].comment = In order to override the default TLS certificate location for
vnc certificates, supply a valid path to the certificate directory.
If the provided path does not exist then the default_tls_x509_cert_dir
path will be used.

libvirtd_qemu__original_configuration[6].value = /etc/pki/libvirt-vnc
libvirtd_qemu__original_configuration[6].section = vnc
libvirtd_qemu__original_configuration[6].state = comment
libvirtd_qemu__original_configuration[6].weight = 4
libvirtd_qemu__original_configuration[7].name = vnc_tls_x509_verify
libvirtd_qemu__original_configuration[7].comment = The default TLS configuration only uses certificates for the server
allowing the client to verify the server identity and establish
an encrypted channel.

It is possible to use x509 certificates for authentication too, by
issuing a x509 certificate to every client who needs to connect.

Enabling this option will reject any client who does not have a
certificate signed by the CA in /etc/pki/libvirt-vnc/ca-cert.pem

If this option is not supplied, it will be set to the value of
"default_tls_x509_verify".

libvirtd_qemu__original_configuration[7].value = True
libvirtd_qemu__original_configuration[7].section = vnc
libvirtd_qemu__original_configuration[7].state = comment
libvirtd_qemu__original_configuration[7].weight = 5
libvirtd_qemu__original_configuration[8].name = vnc_password
libvirtd_qemu__original_configuration[8].comment = The default VNC password. Only 8 bytes are significant for
VNC passwords. This parameter is only used if the per-domain
XML config does not already provide a password. To allow
access without passwords, leave this commented out. An empty
string will still enable passwords, but be rejected by QEMU,
effectively preventing any use of VNC. Obviously change this
example here before you set this.

libvirtd_qemu__original_configuration[8].value = XYZ12345
libvirtd_qemu__original_configuration[8].section = vnc
libvirtd_qemu__original_configuration[8].state = comment
libvirtd_qemu__original_configuration[8].weight = 6
libvirtd_qemu__original_configuration[9].name = vnc_sasl
libvirtd_qemu__original_configuration[9].comment = Enable use of SASL encryption on the VNC server. This requires
a VNC client which supports the SASL protocol extension.
Examples include vinagre, virt-viewer and virt-manager
itself. UltraVNC, RealVNC, TightVNC do not support this

It is necessary to configure /etc/sasl2/qemu.conf to choose
the desired SASL plugin (eg, GSSPI for Kerberos)

libvirtd_qemu__original_configuration[9].value = True
libvirtd_qemu__original_configuration[9].section = vnc
libvirtd_qemu__original_configuration[9].state = comment
libvirtd_qemu__original_configuration[9].weight = 7
libvirtd_qemu__original_configuration[10].name = vnc_sasl_dir
libvirtd_qemu__original_configuration[10].comment = The default SASL configuration file is located in /etc/sasl2/
When running libvirtd unprivileged, it may be desirable to
override the configs in this location. Set this parameter to
point to the directory, and create a qemu.conf in that location

libvirtd_qemu__original_configuration[10].value = /some/directory/sasl2
libvirtd_qemu__original_configuration[10].section = vnc
libvirtd_qemu__original_configuration[10].state = comment
libvirtd_qemu__original_configuration[10].weight = 8
libvirtd_qemu__original_configuration[11].name = vnc_allow_host_audio
libvirtd_qemu__original_configuration[11].comment = QEMU implements an extension for providing audio over a VNC connection,
though if your VNC client does not support it, your only chance for getting
sound output is through regular audio backends. By default, libvirt will
disable all QEMU sound backends if using VNC, since they can cause
permissions issues. Enabling this option will make libvirtd honor the
QEMU_AUDIO_DRV environment variable when using VNC.

libvirtd_qemu__original_configuration[11].value = False
libvirtd_qemu__original_configuration[11].section = vnc
libvirtd_qemu__original_configuration[11].state = comment
libvirtd_qemu__original_configuration[11].weight = 9
libvirtd_qemu__original_configuration[12].name = spice_listen
libvirtd_qemu__original_configuration[12].comment = SPICE is configured to listen on 127.0.0.1 by default.
To make it listen on all public interfaces, uncomment
this next option.

NB, strong recommendation to enable TLS + x509 certificate
verification when allowing public access

libvirtd_qemu__original_configuration[12].value = 0.0.0.0
libvirtd_qemu__original_configuration[12].section = spice
libvirtd_qemu__original_configuration[12].state = comment
libvirtd_qemu__original_configuration[12].weight = 1
libvirtd_qemu__original_configuration[13].name = spice_tls
libvirtd_qemu__original_configuration[13].comment = Enable use of TLS encryption on the SPICE server.

It is necessary to setup CA and issue a server certificate
before enabling this.

libvirtd_qemu__original_configuration[13].value = True
libvirtd_qemu__original_configuration[13].section = spice
libvirtd_qemu__original_configuration[13].state = comment
libvirtd_qemu__original_configuration[13].weight = 2
libvirtd_qemu__original_configuration[14].name = spice_tls_x509_cert_dir
libvirtd_qemu__original_configuration[14].comment = In order to override the default TLS certificate location for
spice certificates, supply a valid path to the certificate directory.
If the provided path does not exist then the default_tls_x509_cert_dir
path will be used.

libvirtd_qemu__original_configuration[14].value = /etc/pki/libvirt-spice
libvirtd_qemu__original_configuration[14].section = spice
libvirtd_qemu__original_configuration[14].state = comment
libvirtd_qemu__original_configuration[14].weight = 3
libvirtd_qemu__original_configuration[15].name = spice_auto_unix_socket
libvirtd_qemu__original_configuration[15].comment = Enable this option to have SPICE served over an automatically created
unix socket. This prevents unprivileged access from users on the
host machine.

This will only be enabled for SPICE configurations that have listen
type=address but without any address specified. This setting takes
preference over spice_listen.

libvirtd_qemu__original_configuration[15].value = True
libvirtd_qemu__original_configuration[15].section = spice
libvirtd_qemu__original_configuration[15].state = comment
libvirtd_qemu__original_configuration[15].weight = 4
libvirtd_qemu__original_configuration[16].name = spice_password
libvirtd_qemu__original_configuration[16].comment = The default SPICE password. This parameter is only used if the
per-domain XML config does not already provide a password. To
allow access without passwords, leave this commented out. An
empty string will still enable passwords, but be rejected by
QEMU, effectively preventing any use of SPICE. Obviously change
this example here before you set this.

libvirtd_qemu__original_configuration[16].value = XYZ12345
libvirtd_qemu__original_configuration[16].section = spice
libvirtd_qemu__original_configuration[16].state = comment
libvirtd_qemu__original_configuration[16].weight = 5
libvirtd_qemu__original_configuration[17].name = spice_sasl
libvirtd_qemu__original_configuration[17].comment = Enable use of SASL encryption on the SPICE server. This requires
a SPICE client which supports the SASL protocol extension.

It is necessary to configure /etc/sasl2/qemu.conf to choose
the desired SASL plugin (eg, GSSPI for Kerberos)

libvirtd_qemu__original_configuration[17].value = True
libvirtd_qemu__original_configuration[17].section = spice
libvirtd_qemu__original_configuration[17].state = comment
libvirtd_qemu__original_configuration[17].weight = 6
libvirtd_qemu__original_configuration[18].name = spice_sasl_dir
libvirtd_qemu__original_configuration[18].comment = The default SASL configuration file is located in /etc/sasl2/
When running libvirtd unprivileged, it may be desirable to
override the configs in this location. Set this parameter to
point to the directory, and create a qemu.conf in that location

libvirtd_qemu__original_configuration[18].value = /some/directory/sasl2
libvirtd_qemu__original_configuration[18].section = spice
libvirtd_qemu__original_configuration[18].state = comment
libvirtd_qemu__original_configuration[18].weight = 7
libvirtd_qemu__original_configuration[19].name = chardev_tls
libvirtd_qemu__original_configuration[19].comment = Enable use of TLS encryption on the chardev TCP transports.

It is necessary to setup CA and issue a server certificate
before enabling this.

libvirtd_qemu__original_configuration[19].value = True
libvirtd_qemu__original_configuration[19].section = chardev
libvirtd_qemu__original_configuration[19].state = comment
libvirtd_qemu__original_configuration[19].weight = 1
libvirtd_qemu__original_configuration[20].name = chardev_tls_x509_cert_dir
libvirtd_qemu__original_configuration[20].comment = In order to override the default TLS certificate location for character
device TCP certificates, supply a valid path to the certificate directory.
If the provided path does not exist then the default_tls_x509_cert_dir
path will be used.

libvirtd_qemu__original_configuration[20].value = /etc/pki/libvirt-chardev
libvirtd_qemu__original_configuration[20].section = chardev
libvirtd_qemu__original_configuration[20].state = comment
libvirtd_qemu__original_configuration[20].weight = 2
libvirtd_qemu__original_configuration[21].name = chardev_tls_x509_verify
libvirtd_qemu__original_configuration[21].comment = The default TLS configuration only uses certificates for the server
allowing the client to verify the server identity and establish
an encrypted channel.

It is possible to use x509 certificates for authentication too, by
issuing a x509 certificate to every client who needs to connect.

Enabling this option will reject any client who does not have a
certificate signed by the CA in /etc/pki/libvirt-chardev/ca-cert.pem

libvirtd_qemu__original_configuration[21].value = True
libvirtd_qemu__original_configuration[21].section = chardev
libvirtd_qemu__original_configuration[21].state = comment
libvirtd_qemu__original_configuration[21].weight = 3
libvirtd_qemu__original_configuration[22].name = chardev_tls_x509_secret_uuid
libvirtd_qemu__original_configuration[22].comment = Uncomment and use the following option to override the default secret
UUID provided in the default_tls_x509_secret_uuid parameter.

NB This default all-zeros UUID will not work. Replace it with the
output from the UUID for the TLS secret from a 'virsh secret-list'
command and then uncomment the entry

libvirtd_qemu__original_configuration[22].value = 00000000-0000-0000-0000-000000000000
libvirtd_qemu__original_configuration[22].section = chardev
libvirtd_qemu__original_configuration[22].state = comment
libvirtd_qemu__original_configuration[22].weight = 4
libvirtd_qemu__original_configuration[23].name = nographics_allow_host_audio
libvirtd_qemu__original_configuration[23].comment = By default, if no graphical front end is configured, libvirt will disable
QEMU audio output since directly talking to alsa/pulseaudio may not work
with various security settings. If you know what you are doing, enable
the setting below and libvirt will passthrough the QEMU_AUDIO_DRV
environment variable when using nographics.

libvirtd_qemu__original_configuration[23].value = True
libvirtd_qemu__original_configuration[23].section = display
libvirtd_qemu__original_configuration[23].state = comment
libvirtd_qemu__original_configuration[23].weight = 1
libvirtd_qemu__original_configuration[24].name = remote_display_port_min
libvirtd_qemu__original_configuration[24].comment = Override the port for creating both VNC and SPICE sessions (min).
This defaults to 5900 and increases for consecutive sessions
or when ports are occupied, until it hits the maximum.

Minimum must be greater than or equal to 5900 as lower number would
result into negative vnc display number.

Maximum must be less than 65536, because higher numbers do not make
sense as a port number.

libvirtd_qemu__original_configuration[24].value = 5900
libvirtd_qemu__original_configuration[24].section = display
libvirtd_qemu__original_configuration[24].state = comment
libvirtd_qemu__original_configuration[24].weight = 2
libvirtd_qemu__original_configuration[25].name = remote_display_port_max
libvirtd_qemu__original_configuration[25].value = 65535
libvirtd_qemu__original_configuration[25].section = display
libvirtd_qemu__original_configuration[25].state = comment
libvirtd_qemu__original_configuration[25].weight = 3
libvirtd_qemu__original_configuration[26].name = remote_websocket_port_min
libvirtd_qemu__original_configuration[26].comment = VNC WebSocket port policies, same rules apply as with remote display
ports. VNC WebSockets use similar display <-> port mappings, with
the exception being that ports start from 5700 instead of 5900.

libvirtd_qemu__original_configuration[26].value = 5700
libvirtd_qemu__original_configuration[26].section = display
libvirtd_qemu__original_configuration[26].state = comment
libvirtd_qemu__original_configuration[26].weight = 4
libvirtd_qemu__original_configuration[27].name = remote_websocket_port_max
libvirtd_qemu__original_configuration[27].value = 65535
libvirtd_qemu__original_configuration[27].section = display
libvirtd_qemu__original_configuration[27].state = comment
libvirtd_qemu__original_configuration[27].weight = 5
libvirtd_qemu__original_configuration[28].name = security_driver
libvirtd_qemu__original_configuration[28].comment = The default security driver is SELinux. If SELinux is disabled
on the host, then the security driver will automatically disable
itself. If you wish to disable QEMU SELinux security driver while
leaving SELinux enabled for the host in general, then set this
to 'none' instead. It is also possible to use more than one security
driver at the same time, for this use a list of names separated by
comma and delimited by square brackets. For example:

      security_driver = [ "selinux", "apparmor" ]

Notes: The DAC security driver is always enabled; as a result, the
value of security_driver cannot contain "dac".  The value "none" is
a special value; security_driver can be set to that value in
isolation, but it cannot appear in a list of drivers.

libvirtd_qemu__original_configuration[28].value = selinux
libvirtd_qemu__original_configuration[28].section = security
libvirtd_qemu__original_configuration[28].state = comment
libvirtd_qemu__original_configuration[28].weight = 1
libvirtd_qemu__original_configuration[29].name = security_default_confined
libvirtd_qemu__original_configuration[29].comment = If set to non-zero, then the default security labeling
will make guests confined. If set to zero, then guests
will be unconfined by default. Defaults to 1.

libvirtd_qemu__original_configuration[29].value = True
libvirtd_qemu__original_configuration[29].section = security
libvirtd_qemu__original_configuration[29].state = comment
libvirtd_qemu__original_configuration[29].weight = 2
libvirtd_qemu__original_configuration[30].name = security_require_confined
libvirtd_qemu__original_configuration[30].comment = If set to non-zero, then attempts to create unconfined
guests will be blocked. Defaults to 0.

libvirtd_qemu__original_configuration[30].value = True
libvirtd_qemu__original_configuration[30].section = security
libvirtd_qemu__original_configuration[30].state = comment
libvirtd_qemu__original_configuration[30].weight = 3
libvirtd_qemu__original_configuration[31].name = user
libvirtd_qemu__original_configuration[31].comment = The user for QEMU processes run by the system instance. It can be
specified as a user name or as a user id. The qemu driver will try to
parse this value first as a name and then, if the name does not exist,
as a user id.

Since a sequence of digits is a valid user name, a leading plus sign
can be used to ensure that a user id will not be interpreted as a user
name.

Some examples of valid values are:

      user = "qemu"   # A user named "qemu"
      user = "+0"     # Super user (uid=0)
      user = "100"    # A user named "100" or a user with uid=100

libvirtd_qemu__original_configuration[31].value = root
libvirtd_qemu__original_configuration[31].section = user-group
libvirtd_qemu__original_configuration[31].state = comment
libvirtd_qemu__original_configuration[31].weight = 1
libvirtd_qemu__original_configuration[32].name = group
libvirtd_qemu__original_configuration[32].comment = The group for QEMU processes run by the system instance. It can be
specified in a similar way to user.

libvirtd_qemu__original_configuration[32].value = root
libvirtd_qemu__original_configuration[32].section = user-group
libvirtd_qemu__original_configuration[32].state = comment
libvirtd_qemu__original_configuration[32].weight = 2
libvirtd_qemu__original_configuration[33].name = dynamic_ownership
libvirtd_qemu__original_configuration[33].comment = Whether libvirt should dynamically change file ownership
to match the configured user/group above. Defaults to 1.
Set to 0 to disable file ownership changes.

libvirtd_qemu__original_configuration[33].value = True
libvirtd_qemu__original_configuration[33].section = user-group
libvirtd_qemu__original_configuration[33].state = comment
libvirtd_qemu__original_configuration[33].weight = 3
libvirtd_qemu__original_configuration[34].name = cgroup_controllers
libvirtd_qemu__original_configuration[34].comment = What cgroup controllers to make use of with QEMU guests

- 'cpu' - use for schedular tunables
- 'devices' - use for device whitelisting
- 'memory' - use for memory tunables
- 'blkio' - use for block devices I/O tunables
- 'cpuset' - use for CPUs and memory nodes
- 'cpuacct' - use for CPUs statistics.

NB, even if configured here, they will not be used unless
the administrator has mounted cgroups, e. g.:

mkdir /dev/cgroup
mount -t cgroup -o devices,cpu,memory,blkio,cpuset none /dev/cgroup

They can be mounted anywhere, and different controllers
can be mounted in different locations. libvirt will detect
where they are located.

libvirtd_qemu__original_configuration[34].value[0] = cpu
libvirtd_qemu__original_configuration[34].value[1] = devices
libvirtd_qemu__original_configuration[34].value[2] = memory
libvirtd_qemu__original_configuration[34].value[3] = blkio
libvirtd_qemu__original_configuration[34].value[4] = cpuset
libvirtd_qemu__original_configuration[34].value[5] = cpuacct
libvirtd_qemu__original_configuration[34].section = cgroup
libvirtd_qemu__original_configuration[34].state = comment
libvirtd_qemu__original_configuration[34].weight = 1
libvirtd_qemu__original_configuration[35].name = cgroup_device_acl
libvirtd_qemu__original_configuration[35].comment = This is the basic set of devices allowed / required by
all virtual machines.

As well as this, any configured block backed disks,
all sound device, and all PTY devices are allowed.

This will only need setting if newer QEMU suddenly
wants some device we do not already know about.

RDMA migration requires the following extra files to be added to the list:
  "/dev/infiniband/rdma_cm",
  "/dev/infiniband/issm0",
  "/dev/infiniband/issm1",
  "/dev/infiniband/umad0",
  "/dev/infiniband/umad1",
  "/dev/infiniband/uverbs0"

libvirtd_qemu__original_configuration[35].value[0] = /dev/null
libvirtd_qemu__original_configuration[35].value[1] = /dev/full
libvirtd_qemu__original_configuration[35].value[2] = /dev/zero
libvirtd_qemu__original_configuration[35].value[3] = /dev/random
libvirtd_qemu__original_configuration[35].value[4] = /dev/urandom
libvirtd_qemu__original_configuration[35].value[5] = /dev/ptmx
libvirtd_qemu__original_configuration[35].value[6] = /dev/kvm
libvirtd_qemu__original_configuration[35].value[7] = /dev/kqemu
libvirtd_qemu__original_configuration[35].value[8] = /dev/rtc
libvirtd_qemu__original_configuration[35].value[9] = /dev/hpet
libvirtd_qemu__original_configuration[35].value[10] = /dev/vfio/vfio
libvirtd_qemu__original_configuration[35].section = cgroup
libvirtd_qemu__original_configuration[35].state = comment
libvirtd_qemu__original_configuration[35].weight = 2
libvirtd_qemu__original_configuration[36].name = save-image_format
libvirtd_qemu__original_configuration[36].comment = The default format for Qemu/KVM guest save images is raw; that is, the
memory from the domain is dumped out directly to a file.  If you have
guests with a large amount of memory, however, this can take up quite
a bit of space.  If you would like to compress the images while they
are being saved to disk, you can also set "lzop", "gzip", "bzip2", or "xz"
for save_image_format.  Note that this means you slow down the process of
saving a domain in order to save disk space; the list above is in descending
order by performance and ascending order by compression ratio.

save_image_format is used when you use 'virsh save' or 'virsh managedsave'
at scheduled saving, and it is an error if the specified save_image_format
is not valid, or the requested compression program cannot be found.

dump_image_format is used when you use 'virsh dump' at emergency
crashdump, and if the specified dump_image_format is not valid, or
the requested compression program cannot be found, this falls
back to "raw" compression.

snapshot_image_format specifies the compression algorithm of the memory save
image when an external snapshot of a domain is taken. This does not apply
on disk image format. It is an error if the specified format is not valid,
or the requested compression program cannot be found.

libvirtd_qemu__original_configuration[36].value = raw
libvirtd_qemu__original_configuration[36].section = dump
libvirtd_qemu__original_configuration[36].state = comment
libvirtd_qemu__original_configuration[36].weight = 1
libvirtd_qemu__original_configuration[37].name = dump_image_format
libvirtd_qemu__original_configuration[37].value = raw
libvirtd_qemu__original_configuration[37].section = dump
libvirtd_qemu__original_configuration[37].state = comment
libvirtd_qemu__original_configuration[37].weight = 2
libvirtd_qemu__original_configuration[38].name = snapshot_image_format
libvirtd_qemu__original_configuration[38].value = raw
libvirtd_qemu__original_configuration[38].section = dump
libvirtd_qemu__original_configuration[38].state = comment
libvirtd_qemu__original_configuration[38].weight = 3
libvirtd_qemu__original_configuration[39].name = auto_dump_path
libvirtd_qemu__original_configuration[39].comment = When a domain is configured to be auto-dumped when libvirtd receives a
watchdog event from qemu guest, libvirtd will save dump files in directory
specified by auto_dump_path. Default value is /var/lib/libvirt/qemu/dump

libvirtd_qemu__original_configuration[39].value = /var/lib/libvirt/qemu/dump
libvirtd_qemu__original_configuration[39].section = dump
libvirtd_qemu__original_configuration[39].state = comment
libvirtd_qemu__original_configuration[39].weight = 4
libvirtd_qemu__original_configuration[40].name = auto_dump_bypass_cache
libvirtd_qemu__original_configuration[40].comment = When a domain is configured to be auto-dumped, enabling this flag
has the same effect as using the VIR_DUMP_BYPASS_CACHE flag with the
virDomainCoreDump API.  That is, the system will avoid using the
file system cache while writing the dump file, but may cause
slower operation.

libvirtd_qemu__original_configuration[40].value = False
libvirtd_qemu__original_configuration[40].section = dump
libvirtd_qemu__original_configuration[40].state = comment
libvirtd_qemu__original_configuration[40].weight = 5
libvirtd_qemu__original_configuration[41].name = auto_start_bypass_cache
libvirtd_qemu__original_configuration[41].comment = When a domain is configured to be auto-started, enabling this flag
has the same effect as using the VIR_DOMAIN_START_BYPASS_CACHE flag
with the virDomainCreateWithFlags API.  That is, the system will
avoid using the file system cache when restoring any managed state
file, but may cause slower operation.

libvirtd_qemu__original_configuration[41].value = False
libvirtd_qemu__original_configuration[41].section = dump
libvirtd_qemu__original_configuration[41].state = comment
libvirtd_qemu__original_configuration[41].weight = 6
libvirtd_qemu__original_configuration[42].name = hugetlbfs_mount
libvirtd_qemu__original_configuration[42].comment = If provided by the host and a hugetlbfs mount point is configured,
a guest may request huge page backing. When this mount point is
unspecified here, determination of a host mount point in /proc/mounts
will be attempted. Specifying an explicit mount overrides detection
of the same in /proc/mounts. Setting the mount point to "" will
disable guest hugepage backing. If desired, multiple mount points can
be specified at once, separated by comma and enclosed in square
brackets, for example:

    hugetlbfs_mount = ["/dev/hugepages2M", "/dev/hugepages1G"]

The size of huge page served by specific mount point is determined by
libvirt at the daemon startup.

NB, within these mount points, guests will create memory backing
files in a location of $MOUNTPOINT/libvirt/qemu

libvirtd_qemu__original_configuration[42].value = /dev/hugepages
libvirtd_qemu__original_configuration[42].section = proc
libvirtd_qemu__original_configuration[42].state = comment
libvirtd_qemu__original_configuration[42].weight = 1
libvirtd_qemu__original_configuration[43].name = bridge_helper
libvirtd_qemu__original_configuration[43].comment = Path to the setuid helper for creating tap devices.  This executable
is used to create <source type='bridge'> interfaces when libvirtd is
running unprivileged.  libvirt invokes the helper directly, instead
of using "-netdev bridge", for security reasons.

libvirtd_qemu__original_configuration[43].value = /usr/libexec/qemu-bridge-helper
libvirtd_qemu__original_configuration[43].section = proc
libvirtd_qemu__original_configuration[43].state = comment
libvirtd_qemu__original_configuration[43].weight = 2
libvirtd_qemu__original_configuration[44].name = clear_emulator_capabilities
libvirtd_qemu__original_configuration[44].comment = If clear_emulator_capabilities is enabled, libvirt will drop all
privileged capabilities of the QEmu/KVM emulator. This is enabled by
default.

Warning: Disabling this option means that a compromised guest can
exploit the privileges and possibly do damage to the host.

libvirtd_qemu__original_configuration[44].value = True
libvirtd_qemu__original_configuration[44].section = proc
libvirtd_qemu__original_configuration[44].state = comment
libvirtd_qemu__original_configuration[44].weight = 3
libvirtd_qemu__original_configuration[45].name = set_process_name
libvirtd_qemu__original_configuration[45].comment = If enabled, libvirt will have QEMU set its process name to
"qemu:VM_NAME", where VM_NAME is the name of the VM. The QEMU
process will appear as "qemu:VM_NAME" in process listings and
other system monitoring tools. By default, QEMU does not set
its process title, so the complete QEMU command (emulator and
its arguments) appear in process listings.

libvirtd_qemu__original_configuration[45].value = True
libvirtd_qemu__original_configuration[45].section = proc
libvirtd_qemu__original_configuration[45].state = comment
libvirtd_qemu__original_configuration[45].weight = 4
libvirtd_qemu__original_configuration[46].name = max_processes
libvirtd_qemu__original_configuration[46].comment = If max_processes is set to a positive integer, libvirt will use
it to set the maximum number of processes that can be run by qemu
user. This can be used to override default value set by host OS.
The same applies to max_files which sets the limit on the maximum
number of opened files.

libvirtd_qemu__original_configuration[46].value = 0
libvirtd_qemu__original_configuration[46].section = proc
libvirtd_qemu__original_configuration[46].state = comment
libvirtd_qemu__original_configuration[46].weight = 5
libvirtd_qemu__original_configuration[47].name = max_files
libvirtd_qemu__original_configuration[47].value = 0
libvirtd_qemu__original_configuration[47].section = proc
libvirtd_qemu__original_configuration[47].state = comment
libvirtd_qemu__original_configuration[47].weight = 6
libvirtd_qemu__original_configuration[48].name = max_core
libvirtd_qemu__original_configuration[48].comment = If max_core is set to a non-zero integer, then QEMU will be
permitted to create core dumps when it crashes, provided its
RAM size is smaller than the limit set.

Be warned that the core dump will include a full copy of the
guest RAM, if the 'dump_guest_core' setting has been enabled,
or if the guest XML contains

  <memory dumpcore="on">...guest ram...</memory>

If guest RAM is to be included, ensure the max_core limit
is set to at least the size of the largest expected guest
plus another 1GB for any QEMU host side memory mappings.

As a special case it can be set to the string "unlimited" to
to allow arbitrarily sized core dumps.

By default the core dump size is set to 0 disabling all dumps

Size is a positive integer specifying bytes or the
string "unlimited"

libvirtd_qemu__original_configuration[48].value = unlimited
libvirtd_qemu__original_configuration[48].section = proc
libvirtd_qemu__original_configuration[48].state = comment
libvirtd_qemu__original_configuration[48].weight = 7
libvirtd_qemu__original_configuration[49].name = dump_guest_core
libvirtd_qemu__original_configuration[49].comment = Determine if guest RAM is included in QEMU core dumps. By
default guest RAM will be excluded if a new enough QEMU is
present. Setting this to '1' will force guest RAM to always
be included in QEMU core dumps.

This setting will be ignored if the guest XML has set the
dumpcore attribute on the <memory> element.

libvirtd_qemu__original_configuration[49].value = True
libvirtd_qemu__original_configuration[49].section = proc
libvirtd_qemu__original_configuration[49].state = comment
libvirtd_qemu__original_configuration[49].weight = 8
libvirtd_qemu__original_configuration[50].name = mac_filter
libvirtd_qemu__original_configuration[50].comment = mac_filter enables MAC addressed based filtering on bridge ports.
This currently requires ebtables to be installed.

libvirtd_qemu__original_configuration[50].value = True
libvirtd_qemu__original_configuration[50].section = proc
libvirtd_qemu__original_configuration[50].state = comment
libvirtd_qemu__original_configuration[50].weight = 9
libvirtd_qemu__original_configuration[51].name = relaxed_acs_check
libvirtd_qemu__original_configuration[51].comment = By default, PCI devices below non-ACS switch are not allowed to be assigned
to guests. By setting relaxed_acs_check to 1 such devices will be allowed to
be assigned to guests.

libvirtd_qemu__original_configuration[51].value = True
libvirtd_qemu__original_configuration[51].section = proc
libvirtd_qemu__original_configuration[51].state = comment
libvirtd_qemu__original_configuration[51].weight = 10
libvirtd_qemu__original_configuration[52].name = allow_disk_format_probing
libvirtd_qemu__original_configuration[52].comment = If allow_disk_format_probing is enabled, libvirt will probe disk
images to attempt to identify their format, when not otherwise
specified in the XML. This is disabled by default.

WARNING: Enabling probing is a security hole in almost all
deployments. It is strongly recommended that users update their
guest XML <disk> elements to include  <driver type='XXXX'/>
elements instead of enabling this option.

libvirtd_qemu__original_configuration[52].value = True
libvirtd_qemu__original_configuration[52].section = proc
libvirtd_qemu__original_configuration[52].state = comment
libvirtd_qemu__original_configuration[52].weight = 11
libvirtd_qemu__original_configuration[53].name = lock_manager
libvirtd_qemu__original_configuration[53].comment = In order to prevent accidentally starting two domains that
share one writable disk, libvirt offers two approaches for
locking files. The first one is sanlock, the other one,
virtlockd, is then our own implementation. Accepted values
are "sanlock" and "lockd".

libvirtd_qemu__original_configuration[53].value = lockd
libvirtd_qemu__original_configuration[53].section = proc
libvirtd_qemu__original_configuration[53].state = comment
libvirtd_qemu__original_configuration[53].weight = 12
libvirtd_qemu__original_configuration[54].name = max_queued
libvirtd_qemu__original_configuration[54].comment = Set limit of maximum APIs queued on one domain. All other APIs
over this threshold will fail on acquiring job lock. Specially,
setting to zero turns this feature off.
Note, that job lock is per domain.

libvirtd_qemu__original_configuration[54].value = 0
libvirtd_qemu__original_configuration[54].section = proc
libvirtd_qemu__original_configuration[54].state = comment
libvirtd_qemu__original_configuration[54].weight = 13
libvirtd_qemu__original_configuration[55].name = keepalive_interval
libvirtd_qemu__original_configuration[55].comment = This allows qemu driver to detect broken connections to remote
libvirtd during peer-to-peer migration.  A keepalive message is
sent to the daemon after keepalive_interval seconds of inactivity
to check if the daemon is still responding; keepalive_count is a
maximum number of keepalive messages that are allowed to be sent
to the daemon without getting any response before the connection
is considered broken.  In other words, the connection is
automatically closed approximately after
keepalive_interval * (keepalive_count + 1) seconds since the last
message received from the daemon.  If keepalive_interval is set to
-1, qemu driver will not send keepalive requests during
peer-to-peer migration; however, the remote libvirtd can still
send them and source libvirtd will send responses.  When
keepalive_count is set to 0, connections will be automatically
closed after keepalive_interval seconds of inactivity without
sending any keepalive messages.

libvirtd_qemu__original_configuration[55].value = 5
libvirtd_qemu__original_configuration[55].section = keepalive
libvirtd_qemu__original_configuration[55].state = comment
libvirtd_qemu__original_configuration[55].weight = 1
libvirtd_qemu__original_configuration[56].name = keepalive_count
libvirtd_qemu__original_configuration[56].value = 5
libvirtd_qemu__original_configuration[56].section = keepalive
libvirtd_qemu__original_configuration[56].state = comment
libvirtd_qemu__original_configuration[56].weight = 2
libvirtd_qemu__original_configuration[57].name = seccomp_sandbox
libvirtd_qemu__original_configuration[57].comment = Use seccomp syscall whitelisting in QEMU.
1 = on, 0 = off, -1 = use QEMU default
Defaults to -1.

libvirtd_qemu__original_configuration[57].value = 1
libvirtd_qemu__original_configuration[57].section = seccomp
libvirtd_qemu__original_configuration[57].state = comment
libvirtd_qemu__original_configuration[57].weight = 1
libvirtd_qemu__original_configuration[58].name = migration_address
libvirtd_qemu__original_configuration[58].comment = Override the listen address for all incoming migrations. Defaults to
0.0.0.0, or :: if both host and qemu are capable of IPv6.

libvirtd_qemu__original_configuration[58].value = 0.0.0.0
libvirtd_qemu__original_configuration[58].section = migration
libvirtd_qemu__original_configuration[58].state = comment
libvirtd_qemu__original_configuration[58].weight = 1
libvirtd_qemu__original_configuration[59].name = migration_host
libvirtd_qemu__original_configuration[59].comment = The default hostname or IP address which will be used by a migration
source for transferring migration data to this host.  The migration
source has to be able to resolve this hostname and connect to it so
setting "localhost" will not work.  By default, the host configured
hostname is used.

libvirtd_qemu__original_configuration[59].value = host.example.com
libvirtd_qemu__original_configuration[59].section = migration
libvirtd_qemu__original_configuration[59].state = comment
libvirtd_qemu__original_configuration[59].weight = 2
libvirtd_qemu__original_configuration[60].name = migration_port_min
libvirtd_qemu__original_configuration[60].comment = Override the port range used for incoming migrations.

Minimum must be greater than 0, however when QEMU is not running as root,
setting the minimum to be lower than 1024 will not work.

Maximum must not be greater than 65535.

libvirtd_qemu__original_configuration[60].value = 49152
libvirtd_qemu__original_configuration[60].section = migration
libvirtd_qemu__original_configuration[60].state = comment
libvirtd_qemu__original_configuration[60].weight = 3
libvirtd_qemu__original_configuration[61].name = migration_port_max
libvirtd_qemu__original_configuration[61].value = 49215
libvirtd_qemu__original_configuration[61].section = migration
libvirtd_qemu__original_configuration[61].state = comment
libvirtd_qemu__original_configuration[61].weight = 4
libvirtd_qemu__original_configuration[62].name = log_timestamp
libvirtd_qemu__original_configuration[62].comment = Timestamp QEMU log messages (if QEMU supports it)

Defaults to 1.

libvirtd_qemu__original_configuration[62].value = False
libvirtd_qemu__original_configuration[62].section = log
libvirtd_qemu__original_configuration[62].state = comment
libvirtd_qemu__original_configuration[62].weight = 1
libvirtd_qemu__original_configuration[63].name = nvram
libvirtd_qemu__original_configuration[63].comment = Location of master nvram file

When a domain is configured to use UEFI instead of standard
BIOS it may use a separate storage for UEFI variables. If
that is the case libvirt creates the variable store per domain
using this master file as image. Each UEFI firmware can,
however, have different variables store. Therefore the nvram is
a list of strings when a single item is in form of:
  ${PATH_TO_UEFI_FW}:${PATH_TO_UEFI_VARS}.
Later, when libvirt creates per domain variable store, this list is
searched for the master image. The UEFI firmware can be called
differently for different guest architectures. For instance, it is OVMF
for x86_64 and i686, but it is AAVMF for aarch64. The libvirt default
follows this scheme.

libvirtd_qemu__original_configuration[63].value[0] = /usr/share/OVMF/OVMF_CODE.fd:/usr/share/OVMF/OVMF_VARS.fd
libvirtd_qemu__original_configuration[63].value[1] = /usr/share/OVMF/OVMF_CODE.secboot.fd:/usr/share/OVMF/OVMF_VARS.fd
libvirtd_qemu__original_configuration[63].value[2] = /usr/share/AAVMF/AAVMF_CODE.fd:/usr/share/AAVMF/AAVMF_VARS.fd
libvirtd_qemu__original_configuration[63].section = nvram
libvirtd_qemu__original_configuration[63].state = comment
libvirtd_qemu__original_configuration[63].weight = 1
libvirtd_qemu__original_configuration[64].name = stdio_handler
libvirtd_qemu__original_configuration[64].comment = The backend to use for handling stdout/stderr output from
QEMU processes.

'file': QEMU writes directly to a plain file. This is the
        historical default, but allows QEMU to inflict a
        denial of service attack on the host by exhausting
        filesystem space

'logd': QEMU writes to a pipe provided by virtlogd daemon.
        This is the current default, providing protection
        against denial of service by performing log file
        rollover when a size limit is hit.

libvirtd_qemu__original_configuration[64].value = logd
libvirtd_qemu__original_configuration[64].section = stdio
libvirtd_qemu__original_configuration[64].state = comment
libvirtd_qemu__original_configuration[64].weight = 1
libvirtd_qemu__original_configuration[65].name = gluster_debug_level
libvirtd_qemu__original_configuration[65].comment = QEMU gluster libgfapi log level, debug levels are 0-9, with 9 being the
most verbose, and 0 representing no debugging output.

The current logging levels defined in the gluster GFAPI are:

  0 - None
  1 - Emergency
  2 - Alert
  3 - Critical
  4 - Error
  5 - Warning
  6 - Notice
  7 - Info
  8 - Debug
  9 - Trace

Defaults to 4

libvirtd_qemu__original_configuration[65].value = 9
libvirtd_qemu__original_configuration[65].section = gluster
libvirtd_qemu__original_configuration[65].state = comment
libvirtd_qemu__original_configuration[65].weight = 1
libvirtd_qemu__original_configuration[66].name = namespaces
libvirtd_qemu__original_configuration[66].comment = To enhance security, QEMU driver is capable of creating private namespaces
for each domain started. Well, so far only "mount" namespace is supported. If
enabled it means qemu process is unable to see all the devices on the system,
only those configured for the domain in question. Libvirt then manages
devices entries throughout the domain lifetime. This namespace is turned on
by default.

libvirtd_qemu__original_configuration[66].value[0] = mount
libvirtd_qemu__original_configuration[66].section = namespaces
libvirtd_qemu__original_configuration[66].state = comment
libvirtd_qemu__original_configuration[66].weight = 1
libvirtd_qemu__default_configuration[0].name = spice_listen
libvirtd_qemu__default_configuration[0].value = {{ libvirtd_qemu__spice_listen }}
libvirtd_qemu__default_configuration[0].state = {{ "present"
               if (libvirtd_qemu__remote_display_allow | d())
               else "ignore" }}
libvirtd_qemu__default_configuration[1].name = vnc_listen
libvirtd_qemu__default_configuration[1].value = {{ libvirtd_qemu__vnc_listen }}
libvirtd_qemu__default_configuration[1].state = {{ "present"
               if (libvirtd_qemu__remote_display_allow | d())
               else "ignore" }}
libvirtd_qemu__default_configuration[2].name = remote_display_port_min
libvirtd_qemu__default_configuration[2].value = {{ libvirtd_qemu__remote_display_port_min }}
libvirtd_qemu__default_configuration[2].state = {{ "present"
               if (libvirtd_qemu__deployment_mode == "opennebula")
               else "ignore" }}
libvirtd_qemu__default_configuration[3].name = remote_display_port_max
libvirtd_qemu__default_configuration[3].value = {{ libvirtd_qemu__remote_display_port_max }}
libvirtd_qemu__default_configuration[3].state = {{ "present"
               if (libvirtd_qemu__deployment_mode == "opennebula")
               else "ignore" }}
libvirtd_qemu__default_configuration[4].name = user
libvirtd_qemu__default_configuration[4].value = {{ libvirtd_qemu__user }}
libvirtd_qemu__default_configuration[4].state = {{ "present"
               if (libvirtd_qemu__deployment_mode == "opennebula")
               else "ignore" }}
libvirtd_qemu__default_configuration[5].name = group
libvirtd_qemu__default_configuration[5].value = {{ libvirtd_qemu__group }}
libvirtd_qemu__default_configuration[5].state = {{ "present"
               if (libvirtd_qemu__deployment_mode == "opennebula")
               else "ignore" }}
libvirtd_qemu__default_configuration[6].name = dynamic_ownership
libvirtd_qemu__default_configuration[6].value = False
libvirtd_qemu__default_configuration[6].state = {{ "present"
               if (libvirtd_qemu__deployment_mode == "opennebula")
               else "ignore" }}
libvirtd_qemu__combined_configuration = {{ libvirtd_qemu__original_configuration
                                           + libvirtd_qemu__default_configuration
                                           + libvirtd_qemu__configuration
                                           + libvirtd_qemu__group_configuration
                                           + libvirtd_qemu__host_configuration }}
libvirtd_qemu__configuration_sections[0].name = tls
libvirtd_qemu__configuration_sections[0].title = TLS configuration
libvirtd_qemu__configuration_sections[0].state = hidden
libvirtd_qemu__configuration_sections[1].name = vnc
libvirtd_qemu__configuration_sections[1].title = VNC display configuration
libvirtd_qemu__configuration_sections[1].state = hidden
libvirtd_qemu__configuration_sections[2].name = spice
libvirtd_qemu__configuration_sections[2].title = SPICE display configuration
libvirtd_qemu__configuration_sections[2].state = hidden
libvirtd_qemu__configuration_sections[3].name = chardev
libvirtd_qemu__configuration_sections[3].title = Character device configuration
libvirtd_qemu__configuration_sections[3].state = hidden
libvirtd_qemu__configuration_sections[4].name = display
libvirtd_qemu__configuration_sections[4].title = Display configuration
libvirtd_qemu__configuration_sections[4].state = hidden
libvirtd_qemu__configuration_sections[5].name = security
libvirtd_qemu__configuration_sections[5].title = Security configuration
libvirtd_qemu__configuration_sections[5].state = hidden
libvirtd_qemu__configuration_sections[6].name = user-group
libvirtd_qemu__configuration_sections[6].title = User and group configuration
libvirtd_qemu__configuration_sections[6].state = hidden
libvirtd_qemu__configuration_sections[7].name = cgroup
libvirtd_qemu__configuration_sections[7].title = Cgroup configuration
libvirtd_qemu__configuration_sections[7].state = hidden
libvirtd_qemu__configuration_sections[8].name = dump
libvirtd_qemu__configuration_sections[8].title = Data dump configuration
libvirtd_qemu__configuration_sections[8].state = hidden
libvirtd_qemu__configuration_sections[9].name = proc
libvirtd_qemu__configuration_sections[9].title = Process configuration
libvirtd_qemu__configuration_sections[9].state = hidden
libvirtd_qemu__configuration_sections[10].name = keepalive
libvirtd_qemu__configuration_sections[10].title = Keepalive configuration
libvirtd_qemu__configuration_sections[10].state = hidden
libvirtd_qemu__configuration_sections[11].name = seccomp
libvirtd_qemu__configuration_sections[11].title = SecComp configuration
libvirtd_qemu__configuration_sections[11].state = hidden
libvirtd_qemu__configuration_sections[12].name = migration
libvirtd_qemu__configuration_sections[12].title = Migration configuration
libvirtd_qemu__configuration_sections[12].state = hidden
libvirtd_qemu__configuration_sections[13].name = log
libvirtd_qemu__configuration_sections[13].title = Logging configuration
libvirtd_qemu__configuration_sections[13].state = hidden
libvirtd_qemu__configuration_sections[14].name = nvram
libvirtd_qemu__configuration_sections[14].title = NVRAM configuration
libvirtd_qemu__configuration_sections[14].state = hidden
libvirtd_qemu__configuration_sections[15].name = stdio
libvirtd_qemu__configuration_sections[15].title = IO configuration
libvirtd_qemu__configuration_sections[15].state = hidden
libvirtd_qemu__configuration_sections[16].name = gluster
libvirtd_qemu__configuration_sections[16].title = GlusterFS configuration
libvirtd_qemu__configuration_sections[16].state = hidden
libvirtd_qemu__configuration_sections[17].name = namespaces
libvirtd_qemu__configuration_sections[17].title = Namespaces configuration
libvirtd_qemu__configuration_sections[17].state = hidden
libvirtd_qemu__configuration_sections[18].name = unknown
libvirtd_qemu__configuration_sections[18].title = Other configuration
libvirtd_qemu__configuration_sections[18].state = hidden
libvirtd_qemu__configuration_comments = True
libvirtd_qemu__ferm__dependent_rules[0].name = libvirtd_qemu__remote_display
libvirtd_qemu__ferm__dependent_rules[0].type = accept
libvirtd_qemu__ferm__dependent_rules[0].dport = {{ libvirtd_qemu__remote_display_ports }}
libvirtd_qemu__ferm__dependent_rules[0].saddr = {{ libvirtd_qemu__remote_display_allow }}
libvirtd_qemu__ferm__dependent_rules[0].accept_any = False
libvirtd_qemu__ferm__dependent_rules[0].rule_state = {{ "present"
                    if (libvirtd_qemu__deployment_mode == "opennebula")
                    else "absent" }}
