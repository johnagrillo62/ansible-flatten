~d0.name = Check if secret for encrypting data at rest already exist
~d1.stat = 
~d2.path = "{{ kube_cert_dir }}/secrets_encryption.yaml"
~d2.get_attributes = false
~d2.get_checksum = false
~d2.get_mime = false
~d1.register = secrets_encryption_file
~d0.name = Slurp secrets_encryption file if it exists
~d1.slurp = 
~d2.src = "{{ kube_cert_dir }}/secrets_encryption.yaml"
~d1.register = secret_file_encoded
~d1.when = secrets_encryption_file.stat.exists
~d0.name = Base 64 Decode slurped secrets_encryption.yaml file
~d1.set_fact = 
~d2.secret_file_decoded = "{{ secret_file_encoded['content'] | b64decode | from_yaml }}"
~d1.when = secrets_encryption_file.stat.exists
~d0.name = Extract secret value from secrets_encryption.yaml
~d1.set_fact = 
~d2.kube_encrypt_token_extracted = "{{ secret_file_decoded | json_query(secrets_encryption_query) | first | b64decode }}"
~d1.when = secrets_encryption_file.stat.exists
~d0.name = Set kube_encrypt_token across control plane nodes
~d1.set_fact = 
~d2.kube_encrypt_token = "{{ kube_encrypt_token_extracted }}"
~d1.delegate_to = "{{ item }}"
~d1.delegate_facts = true
~d1.with_inventory_hostnames = kube_control_plane
~d1.when = kube_encrypt_token_extracted is defined
~d0.name = Write secrets for encrypting secret data at rest
~d1.template = 
~d2.src = secrets_encryption.yaml.j2
~d2.dest = "{{ kube_cert_dir }}/secrets_encryption.yaml"
~d2.owner = root
~d2.group = "{{ kube_cert_group }}"
~d2.mode = "0640"
