~d0.name = Import DebOps secret role
~d1.ansible.builtin.import_role = 
~d2.name = 'secret'
~d0.name = Create required groups
~d1.ansible.builtin.group = 
~d2.name = '{{ item.name if item.name | d() else item }}'
~d2.system = '{{ item.system | bool if item.system is defined else gitlab_runner__system | bool }}'
~d2.state = 'present'
~d1.loop = '{{ q("flattened", [gitlab_runner__group]
~d0.name = Create gitlab-runner user
~d1.ansible.builtin.user = 
~d2.name = '{{ gitlab_runner__user }}'
~d2.group = '{{ gitlab_runner__group }}'
~d2.groups = '{{ gitlab_runner__additional_groups | map(attribute="name") | list | join(",") }}'
~d2.append = True
~d2.home = '{{ gitlab_runner__home }}'
~d2.system = '{{ gitlab_runner__system | bool }}'
~d2.comment = '{{ gitlab_runner__comment }}'
~d2.shell = '{{ gitlab_runner__shell }}'
~d2.state = 'present'
~d2.generate_ssh_key = '{{ gitlab_runner__ssh_generate | bool }}'
~d2.ssh_key_bits = '{{ gitlab_runner__ssh_generate_bits }}'
~d2.skeleton = null
~d0.name = Remove '~/.bash_logout' to avoid conflicts with the shell runner
~d1.ansible.builtin.file = 
~d2.state = 'absent'
~d2.path = "{{ gitlab_runner__home }}/.bash_logout"
~d0.name = Allow Docker access for gitlab-runner user
~d1.ansible.builtin.user = 
~d2.name = '{{ gitlab_runner__user }}'
~d2.groups = 'docker'
~d2.append = True
~d1.when = (ansible_local | d() and ansible_local.docker_server | d() and
~d0.name = Copy custom files to GitLab Runner host
~d1.ansible.builtin.copy = 
~d2.src = '{{ item.src | d(omit) }}'
~d2.content = '{{ item.content | d(omit) }}'
~d2.dest = '{{ item.dest }}'
~d2.owner = '{{ item.owner | d(omit) }}'
~d2.group = '{{ item.group | d(omit) }}'
~d2.mode = '{{ item.mode | d(omit) }}'
~d2.directory_mode = '{{ item.directory_mode | d(omit) }}'
~d2.follow = '{{ item.follow | d(omit) }}'
~d2.force = '{{ item.force | d(omit) }}'
~d1.loop = '{{ q("flattened", gitlab_runner__custom_files
~d1.when = ((item.src | d() or item.content | d()) and item.dest | d())
~d0.name = Make sure APT can access HTTPS repositories
~d1.ansible.builtin.apt = 
~d2.name = [ 'apt-transport-https', 'openssl', 'ca-certificates' ]
~d2.state = 'present'
~d2.install_recommends = False
~d2.update_cache = True
~d2.cache_valid_time = '{{ ansible_local.core.cache_valid_time | d("86400") }}'
~d1.register = gitlab_runner__register_apt_https
~d1.until = gitlab_runner__register_apt_https is succeeded
~d0.name = Install gitlab-runner packages
~d1.ansible.builtin.apt = 
~d2.name = "{{ query('flattened', gitlab_runner__base_packages +
~d2.state = 'present'
~d2.install_recommends = False
~d1.register = gitlab_runner__register_packages
~d1.until = gitlab_runner__register_packages is succeeded
~d0.name = Register new GitLab Runners
~d1.ansible.builtin.uri = 
~d2.url = '{{ (item.api_url | d(gitlab_runner__api_url)) + "api/v4/user/runners" }}'
~d2.method = 'POST'
~d2.headers = 
~d3.'PRIVATE-TOKEN' = '{{ item.api_token | d(gitlab_runner__api_token) }}'
~d2.body_format = 'form-urlencoded'
~d2.body = 
~d3.runner_type = '{{ item.runner_type | d(gitlab_runner__runner_type) }}'
~d3.group_id = '{{ item.group_id | d(gitlab_runner__group_id) | d(omit) }}'
~d3.project_id = '{{ item.project_id | d(gitlab_runner__project_id) | d(omit) }}'
~d3.description = '{{ item.name }}'
~d3.tag_list = '{{ (item.tags | d([])
~d3.run_untagged = '{{ item.run_untagged | d(gitlab_runner__run_untagged) }}'
~d3.paused = '{{ item.paused | d(omit) }}'
~d3.locked = '{{ item.locked | d(omit) }}'
~d3.access_level = '{{ item.access_level | d(omit) }}'
~d3.maximum_timeout = '{{ item.maximum_timeout | d(omit) }}'
~d3.maintenance_note = '{{ item.maintenance_note | d(omit) }}'
~d2.status_code = '200,201'
~d1.register = gitlab_runner__register_new_instances
~d1.loop = '{{ q("flattened", gitlab_runner__default_instances
~d1.when = ((item.api_token | d() or gitlab_runner__api_token) and item.name and
~d0.name = Generate GitLab Runner configuration files
~d1.ansible.builtin.template = 
~d2.src = 'etc/gitlab-runner/{{ item }}.j2'
~d2.dest = '/etc/gitlab-runner/{{ item }}'
~d2.owner = 'root'
~d2.group = 'root'
~d2.mode = '0600'
~d1.with_items = [ 'config.toml', 'ansible.json' ]
~d0.name = Delete GitLab Runners if requested
~d1.ansible.builtin.uri = 
~d2.url = '{{ (item.0.api_url | d(gitlab_runner__api_url)) + "api/v4/runners/" + item.1.id | string }}'
~d2.method = 'DELETE'
~d2.headers = 
~d3.'PRIVATE-TOKEN' = '{{ item.0.api_token | d(gitlab_runner__api_token) }}'
~d1.with_together = 
~d1.when = ((item.0.api_token | d() or gitlab_runner__api_token)
~d1.failed_when = False
~d1.no_log = '{{ debops__no_log | d(True) }}'
~d0.name = Get the SSH key from the remote host
~d1.ansible.builtin.slurp = 
~d2.src = '~{{ gitlab_runner__user }}/.ssh/id_rsa.pub'
~d1.register = gitlab_runner__register_ssh_key
~d1.when = gitlab_runner__ssh_generate | bool
~d0.name = Distribute SSH key to other hosts
~d1.ansible.posix.authorized_key = 
~d2.key = '{{ gitlab_runner__register_ssh_key.content | b64decode | trim }}'
~d2.user = '{{ item.user }}'
~d2.state = 'present'
~d2.key_options = '{{ item.options | d() }}'
~d1.delegate_to = '{{ item.host }}'
~d1.become = '{{ item.become | d(True) }}'
~d1.with_items = '{{ gitlab_runner__ssh_install_to }}'
~d1.when = gitlab_runner__ssh_generate | bool and item.user | d() and item.host | d()
~d0.name = Make sure that the ~/.ssh directory exists
~d1.ansible.builtin.file = 
~d2.path = '{{ gitlab_runner__home }}/.ssh'
~d2.state = 'directory'
~d2.owner = '{{ gitlab_runner__user }}'
~d2.group = '{{ gitlab_runner__group }}'
~d2.mode = '0700'
~d1.when = gitlab_runner__ssh_known_hosts | d()
~d0.name = Make sure the ~/.ssh/known_hosts file exists
~d1.ansible.builtin.copy = 
~d2.content = ''
~d2.dest = '{{ gitlab_runner__home }}/.ssh/known_hosts'
~d2.owner = '{{ gitlab_runner__user }}'
~d2.group = '{{ gitlab_runner__group }}'
~d2.mode = '0644'
~d2.force = False
~d1.when = gitlab_runner__ssh_known_hosts | d()
~d0.name = Get list of already scanned host fingerprints
~d1.ansible.builtin.shell = set -o nounset -o pipefail -o errexit &&
~d1.args = 
~d2.executable = 'bash'
~d1.with_items = '{{ gitlab_runner__ssh_known_hosts }}'
~d1.when = gitlab_runner__ssh_known_hosts | d()
~d1.register = gitlab_runner__register_known_hosts
~d1.changed_when = False
~d1.failed_when = False
~d1.check_mode = False
~d0.name = Scan SSH fingerprints of specified hosts
~d1.ansible.builtin.shell = 'ssh-keyscan -H -T 10 {{ item.item }} >> {{ gitlab_runner__home + "/.ssh/known_hosts" }}'
~d1.with_items = '{{ gitlab_runner__register_known_hosts.results }}'
~d1.register = gitlab_runner__register_keyscan
~d1.changed_when = gitlab_runner__register_keyscan.changed | bool
~d1.when = gitlab_runner__ssh_known_hosts and item is defined and item.rc > 0
~d1.failed_when = False
~d0.name = Configure Vagrant libvirt access
~d1.ansible.builtin.user = 
~d2.name = '{{ gitlab_runner__user }}'
~d2.append = True
~d2.groups = '{{ ([ansible_local.libvirtd.unix_sock_group
~d1.when = gitlab_runner__vagrant_libvirt | bool
~d0.name = Configure Vagrant libvirt sudo access
~d1.ansible.builtin.template = 
~d2.src = 'etc/sudoers.d/gitlab-runner-vagrant-libvirt.j2'
~d2.dest = '/etc/sudoers.d/gitlab-runner-vagrant-libvirt'
~d2.owner = 'root'
~d2.group = 'root'
~d2.mode = '0440'
~d1.when = (ansible_local | d() and ansible_local.sudo | d() and
~d0.name = Find 'vagrant-libvirt' source code
~d1.ansible.builtin.command = find /usr/share/rubygems-integration/all/gems -maxdepth 1 -type d -name 'vagrant-libvirt-*'
~d1.register = gitlab_runner__register_libvirt_source
~d1.when = gitlab_runner__vagrant_libvirt_patch | bool
~d1.changed_when = False
~d1.check_mode = False
~d1.tags = [ 'role::gitlab_runner:patch' ]
~d0.name = Patch 'vagrant-libvirt' source code
~d1.ansible.posix.patch = 
~d2.src = '{{ "patches/package_domain-keep-ssh-host-keys-"
~d2.basedir = '{{ item }}'
~d2.state = '{{ gitlab_runner__vagrant_libvirt_patch_state }}'
~d1.with_items = '{{ gitlab_runner__register_libvirt_source.stdout_lines }}'
~d1.when = gitlab_runner__vagrant_libvirt_patch | bool
~d1.tags = [ 'role::gitlab_runner:patch' ]
~d0.name = Configure Vagrant LXC sudo access
~d1.ansible.builtin.template = 
~d2.src = 'etc/sudoers.d/gitlab-runner-vagrant-lxc.j2'
~d2.dest = '/etc/sudoers.d/gitlab-runner-vagrant-lxc'
~d2.owner = 'root'
~d2.group = 'root'
~d2.mode = '0440'
~d1.when = (ansible_local | d() and ansible_local.sudo | d() and
~d0.name = Make sure that Ansible fact directory exists
~d1.ansible.builtin.file = 
~d2.path = '/etc/ansible/facts.d'
~d2.state = 'directory'
~d2.owner = 'root'
~d2.group = 'root'
~d2.mode = '0755'
~d0.name = Save GitLab Runner local facts
~d1.ansible.builtin.template = 
~d2.src = 'etc/ansible/facts.d/gitlab_runner.fact.j2'
~d2.dest = '/etc/ansible/facts.d/gitlab_runner.fact'
~d2.owner = 'root'
~d2.group = 'root'
~d2.mode = '0755'
~d1.tags = [ 'meta::facts' ]
