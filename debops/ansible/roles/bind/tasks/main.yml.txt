~d0.name = Import custom Ansible plugins
~d1.ansible.builtin.import_role = 
~d2.name = 'ansible_plugins'
~d0.name = Import DebOps global handlers
~d1.ansible.builtin.import_role = 
~d2.name = 'global_handlers'
~d1.tags = [ 'role::bind:config' ]
~d0.name = Import DebOps secret role
~d1.ansible.builtin.import_role = 
~d2.name = 'secret'
~d1.tags = [ 'role::bind:keys' ]
~d0.name = Install packages
~d1.ansible.builtin.package = 
~d2.name = '{{ q("flattened", bind__base_packages + bind__packages) }}'
~d2.state = 'present'
~d1.register = bind__register_packages
~d1.until = bind__register_packages is succeeded
~d1.tags = [ 'role::bind:packages' ]
~d0.name = Make sure that the Ansible local facts directory exists
~d1.ansible.builtin.file = 
~d2.path = '/etc/ansible/facts.d'
~d2.state = 'directory'
~d2.mode = '0755'
~d1.tags = [ 'role::bind:config' ]
~d0.name = Save local facts
~d1.ansible.builtin.template = 
~d2.src = 'etc/ansible/facts.d/bind.fact.j2'
~d2.dest = '/etc/ansible/facts.d/bind.fact'
~d2.mode = '0755'
~d1.notify = [ 'Refresh host facts' ]
~d1.tags = [ 'meta::facts', 'role::bind:config' ]
~d0.name = Update Ansible facts if they were modified
~d1.ansible.builtin.meta = 'flush_handlers'
~d1.tags = [ 'role::bind:config' ]
~d0.name = Enable/disable resolvconf integration
~d1.ansible.builtin.service = 
~d2.name = 'named-resolvconf'
~d2.enabled = '{{ ansible_local.resolvconf.installed | d(False) | bool }}'
~d1.when = ansible_service_mgr == "systemd"
~d1.tags = [ 'role::bind:config' ]
~d0.name = Allow access to additional UNIX groups
~d1.ansible.builtin.user = 
~d2.name = '{{ bind__user }}'
~d2.groups = '{{ bind__additional_groups }}'
~d2.append = True
~d2.state = 'present'
~d1.register = bind__register_unix_groups
~d1.notify = [ 'Test named configuration and restart' ]
~d0.name = Create base directories
~d1.ansible.builtin.file = 
~d2.path = '{{ item.path }}'
~d2.state = 'directory'
~d2.owner = 'root'
~d2.group = 'bind'
~d2.mode = '{{ item.mode | d("0775") }}'
~d1.loop = 
~d2.{ path = '/etc/bind', mode: '02755' }
~d2.{ path = '/etc/bind/keys', mode: '02750' }
~d2.{ path = '/var/cache/bind' }
~d2.{ path = '/var/lib/bind' }
~d2.{ path = '/var/lib/bind/views' }
~d2.{ path = '/var/lib/bind/dnssec-keys', mode: '02770' }
~d2.{ path = '/var/log/named' }
~d1.notify = [ 'Test named configuration and restart' ]
~d1.tags = [ 'role::bind:config' ]
~d0.name = Create keys
~d1.ansible.builtin.include_tasks = 'main_keys.yml'
~d1.tags = [ 'role::bind:config', 'role::bind:keys' ]
~d0.name = Generate list of toplevel views
~d1.ansible.builtin.set_fact = 
~d2.bind__tmp_top_views = '{{ bind__combined_zones
~d1.tags = [ 'role::bind:config' ]
~d0.name = Generate list of toplevel zones
~d1.ansible.builtin.set_fact = 
~d2.bind__tmp_top_zones = '{{ bind__combined_zones
~d1.tags = [ 'role::bind:config' ]
~d0.name = Make sure either zones or views are defined
~d1.ansible.builtin.assert = 
~d2.that = bind__tmp_top_views | length == 0 or bind__tmp_top_zones | length == 0
~d1.tags = [ 'role::bind:config' ]
~d0.name = Assign zones to the default view
~d1.ansible.builtin.set_fact = 
~d2.bind__tmp_top_views = 
~d3.view = '_default'
~d4.zones = '{{ bind__tmp_top_zones }}'
~d1.when = bind__tmp_top_views | length == 0
~d1.tags = [ 'role::bind:config' ]
~d0.name = Create list of generic zones
~d1.ansible.builtin.set_fact = 
~d2.bind__tmp_generic_zones = '{{ bind__combined_generic_zones
~d1.tags = [ 'role::bind:config' ]
~d0.name = Add generic zones to each view
~d1.ansible.builtin.set_fact = 
~d2.bind__tmp_full_views = '{{ bind__tmp_full_views | d([])
~d15.+ [item | combine({"zones" = item["zones"]
~d1.loop = '{{ bind__tmp_top_views }}'
~d1.loop_control = 
~d2.label = '{{ item.view }}'
~d1.tags = [ 'role::bind:config' ]
~d0.name = Register the view in each zone
~d1.ansible.builtin.set_fact = 
~d2.bind__views = '{{ bind__views | d([])
~d10.+ [item | combine({"zones" = (item["zones"]
~d25.| map("combine", {"view" = item["view"]}))})] }}'
~d1.loop = '{{ bind__tmp_full_views }}'
~d1.loop_control = 
~d2.label = '{{ item.view }}'
~d1.tags = [ 'role::bind:config' ]
~d0.name = Create zone directories
~d1.ansible.builtin.file = 
~d2.path = '{{ item.dir | d("/var/lib/bind/views/" + item.view + "/" + item.name) }}'
~d2.state = 'directory'
~d2.owner = '{{ item.owner | d("root") }}'
~d2.group = '{{ item.group | d("bind") }}'
~d2.mode = '{{ item.mode | d("0775") }}'
~d1.loop = '{{ bind__views | map(attribute="zones") | flatten }}'
~d1.when = 
~d1.loop_control = 
~d2.label = '{{ item.dir | d("/var/lib/bind/views/" + item.view + "/" + item.name) }}'
~d1.notify = [ 'Test named configuration and restart' ]
~d1.tags = [ 'role::bind:config' ]
~d0.name = Suspend dynamic updates
~d1.ansible.builtin.shell = |
~d1.environment = 
~d2.LC_ALL = 'C'
~d1.register = bind__register_freeze
~d1.changed_when = False
~d1.failed_when = >
~d1.tags = [ 'role::bind:config' ]
~d0.name = Register the fact that this role suspended dynamic updates
~d1.ansible.builtin.file = 
~d2.path = '/var/lib/bind/.debops.frozen'
~d2.state = 'touch'
~d2.mode = '0644'
~d1.changed_when = False
~d1.when = bind__register_freeze.rc == 222
~d1.tags = [ 'role::bind:config' ]
~d0.name = Generate zone files
~d1.ansible.builtin.template = 
~d2.src = 'var/lib/bind/views/view/zone/db.zone.j2'
~d2.dest = '{{ (item.dir | d("/var/lib/bind/views/" + item.view + "/" + item.name)) + "/db.zone" }}'
~d2.owner = '{{ item.owner | d("root") }}'
~d2.group = '{{ item.group | d("bind") }}'
~d2.mode = '{{ item.mode | d("0644") }}'
~d2.force = '{{ item.force | d(False) }}'
~d1.loop = '{{ bind__views | map(attribute="zones") | flatten }}'
~d1.when = 
~d1.loop_control = 
~d2.label = '{{ (item.dir | d("/var/lib/bind/views/" + item.view + "/" + item.name)) + "/db.zone" }}'
~d1.notify = [ 'Test named configuration and restart' ]
~d1.tags = [ 'role::bind:config' ]
~d0.name = Divert the BIND configuration
~d1.debops.debops.dpkg_divert = 
~d2.path = '/etc/bind/named.conf'
~d1.tags = [ 'role::bind:config' ]
~d0.name = Generate BIND configuration
~d1.ansible.builtin.template = 
~d2.src = 'etc/bind/named.conf.j2'
~d2.dest = '/etc/bind/named.conf'
~d2.owner = 'root'
~d2.group = 'bind'
~d2.mode = '0644'
~d1.notify = [ 'Test named configuration and restart' ]
~d1.tags = [ 'role::bind:config' ]
~d0.name = Make sure named is restarted, if necessary
~d1.ansible.builtin.meta = 'flush_handlers'
~d1.tags = [ 'role::bind:config' ]
~d0.name = Check if dynamic updates should be resumed
~d1.ansible.builtin.stat = 
~d2.path = '/var/lib/bind/.debops.frozen'
~d1.changed_when = False
~d1.register = bind__register_should_thaw
~d1.tags = [ 'role::bind:config' ]
~d0.name = Resume dynamic updates
~d1.ansible.builtin.command = rndc thaw
~d1.when = bind__register_should_thaw.stat.exists | d(False)
~d1.register = bind__register_thaw
~d1.until = bind__register_thaw is succeeded
~d1.changed_when = False
~d1.tags = [ 'role::bind:config' ]
~d0.name = Remove dynamic update flag file
~d1.ansible.builtin.file = 
~d2.path = '/var/lib/bind/.debops.frozen'
~d2.state = 'absent'
~d1.changed_when = False
~d1.tags = [ 'role::bind:config' ]
~d0.name = Install backup snapshot script
~d1.ansible.builtin.copy = 
~d2.src = 'usr/local/sbin/debops-bind-snapshot'
~d2.dest = '/usr/local/sbin/debops-bind-snapshot'
~d2.owner = 'root'
~d2.group = 'root'
~d2.mode = '0755'
~d1.tags = [ 'role::bind:backup' ]
~d0.name = Configure backup snapshots as cron jobs
~d1.ansible.builtin.cron = 
~d2.name = 'Create {{ item }} backup snapshots of BIND configuration and zones'
~d2.special_time = '{{ item }}'
~d2.cron_file = 'debops-bind-snapshot'
~d2.user = 'root'
~d2.state = '{{ "present"
~d2.job = '/usr/local/sbin/debops-bind-snapshot {{ item }}'
~d1.loop = [ 'daily', 'weekly', 'monthly' ]
~d1.loop_control = 
~d2.label = '{{ {"state": ("present"
~d8."cron_job" = item} }}'
~d1.tags = [ 'role::bind:backup' ]
~d0.name = Make sure that the PKI hook directory exists
~d1.ansible.builtin.file = 
~d2.path = '{{ bind__pki_hook_path }}'
~d2.state = 'directory'
~d2.owner = 'root'
~d2.group = 'root'
~d2.mode = '0755'
~d1.when = '"dot" in bind__features or "doh_https" in bind__features'
~d1.tags = [ 'role::bind:pki' ]
~d0.name = Install the BIND PKI hook
~d1.ansible.builtin.template = 
~d2.src = 'etc/pki/hooks/bind.j2'
~d2.dest = '{{ bind__pki_hook_path + "/" + bind__pki_hook_name }}'
~d2.owner = 'root'
~d2.group = 'root'
~d2.mode = '0755'
~d1.when = '"dot" in bind__features or "doh_https" in bind__features'
~d1.tags = [ 'role::bind:pki' ]
~d0.name = Remove the BIND PKI hook
~d1.ansible.builtin.file = 
~d2.dest = '{{ bind__pki_hook_path + "/" + bind__pki_hook_name }}'
~d2.state = 'absent'
~d1.when = '"dot" not in bind__features and "doh_https" not in bind__features'
~d1.tags = [ 'role::bind:pki' ]
~d0.name = Install DNSSEC rollover configuration
~d1.ansible.builtin.template = 
~d2.src = 'etc/bind/debops-bind-rollkey.json.j2'
~d2.dest = '/etc/bind/debops-bind-rollkey.json'
~d2.owner = 'root'
~d2.group = 'root'
~d2.mode = '0644'
~d1.when = '"dnssec" in bind__features and bind__dnssec_script_enabled | d(False)'
~d1.tags = [ 'role::bind:dnssec' ]
~d0.name = Install DNSSEC rollover script
~d1.ansible.builtin.copy = 
~d2.src = 'usr/local/sbin/debops-bind-rollkey'
~d2.dest = '/usr/local/sbin/debops-bind-rollkey'
~d2.owner = 'root'
~d2.group = 'root'
~d2.mode = '0755'
~d1.when = '"dnssec" in bind__features and bind__dnssec_script_enabled | d(False)'
~d1.tags = [ 'role::bind:dnssec' ]
~d0.name = Install DNSSEC rollover external script
~d1.ansible.builtin.copy = 
~d2.src = '{{ lookup("debops.debops.file_src",
~d2.dest = '/usr/local/sbin/debops-bind-rollkey-action'
~d2.owner = 'root'
~d2.group = 'root'
~d2.mode = '0755'
~d1.when = 
~d1.tags = [ 'role::bind:dnssec' ]
~d0.name = Enable DNSSEC rollover cron job
~d1.ansible.builtin.cron = 
~d2.name = 'Rollover DNSSEC keys for BIND'
~d2.special_time = 'weekly'
~d2.cron_file = 'debops-bind-rollkey'
~d2.user = 'root'
~d2.job = '/usr/local/sbin/debops-bind-rollkey'
~d2.state = '{{ "present"
~d1.tags = [ 'role::bind:dnssec' ]
~d0.name = Remove DNSSEC rollover script
~d1.ansible.builtin.file = 
~d2.path = '{{ item }}'
~d2.state = 'absent'
~d1.loop = 
~d1.when = '"dnssec" not in bind__features or not bind__dnssec_script_enabled | d(False)'
~d1.tags = [ 'role::bind:dnssec' ]
