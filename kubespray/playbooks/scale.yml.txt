~d0.name = Common tasks for every playbooks
~d1.import_playbook = boilerplate.yml
~d0.name = Gather facts
~d1.import_playbook = internal_facts.yml
~d0.name = Install etcd
~d1.vars = 
~d2.etcd_cluster_setup = false
~d2.etcd_events_cluster_setup = false
~d1.import_playbook = install_etcd.yml
~d0.name = Download images to ansible host cache via first kube_control_plane node
~d1.hosts = kube_control_plane[0]
~d1.gather_facts = false
~d1.any_errors_fatal = "{{ any_errors_fatal | default(true) }}"
~d1.environment = "{{ proxy_disable_env }}"
~d1.roles = 
~d2.{ role = kubespray_defaults, when: "not skip_downloads and download_run_once and not download_localhost" }
~d2.{ role = kubernetes/preinstall, tags: preinstall, when: "not skip_downloads and download_run_once and not download_localhost" }
~d2.{ role = download, tags: download, when: "not skip_downloads and download_run_once and not download_localhost" }
~d0.name = Target only workers to get kubelet installed and checking in on any new nodes(engine)
~d1.hosts = kube_node
~d1.gather_facts = false
~d1.any_errors_fatal = "{{ any_errors_fatal | default(true) }}"
~d1.environment = "{{ proxy_disable_env }}"
~d1.roles = 
~d2.{ role = kubespray_defaults }
~d2.{ role = kubernetes/preinstall, tags: preinstall }
~d2.{ role = container-engine, tags: "container-engine", when: deploy_container_engine }
~d2.{ role = download, tags: download, when: "not skip_downloads" }
~d2.role = etcd
~d3.tags = etcd
~d3.vars = 
~d4.etcd_cluster_setup = false
~d3.when = 
~d0.name = Target only workers to get kubelet installed and checking in on any new nodes(node)
~d1.hosts = kube_node
~d1.gather_facts = false
~d1.any_errors_fatal = "{{ any_errors_fatal | default(true) }}"
~d1.environment = "{{ proxy_disable_env }}"
~d1.roles = 
~d2.{ role = kubespray_defaults }
~d2.{ role = kubernetes/node, tags: node }
~d0.name = Upload control plane certs and retrieve encryption key
~d1.hosts = kube_control_plane | first
~d1.environment = "{{ proxy_disable_env }}"
~d1.gather_facts = false
~d1.tags = kubeadm
~d1.roles = 
~d2.{ role = kubespray_defaults }
~d1.tasks = 
~d2.name = Upload control plane certificates
~d3.command = >-
~d3.environment = "{{ proxy_disable_env }}"
~d3.register = kubeadm_upload_cert
~d3.changed_when = false
~d2.name = Set fact 'kubeadm_certificate_key' for later use
~d3.set_fact = 
~d4.kubeadm_certificate_key = "{{ kubeadm_upload_cert.stdout_lines[-1] | trim }}"
~d3.when = kubeadm_certificate_key is not defined
~d0.name = Target only workers to get kubelet installed and checking in on any new nodes(network)
~d1.hosts = kube_node
~d1.gather_facts = false
~d1.any_errors_fatal = "{{ any_errors_fatal | default(true) }}"
~d1.environment = "{{ proxy_disable_env }}"
~d1.roles = 
~d2.{ role = kubespray_defaults }
~d2.{ role = kubernetes/kubeadm, tags: kubeadm }
~d2.{ role = kubernetes/node-label, tags: node-label }
~d2.{ role = kubernetes/node-taint, tags: node-taint }
~d2.{ role = network_plugin, tags: network }
~d0.name = Apply resolv.conf changes now that cluster DNS is up
~d1.hosts = k8s_cluster
~d1.gather_facts = false
~d1.any_errors_fatal = "{{ any_errors_fatal | default(true) }}"
~d1.environment = "{{ proxy_disable_env }}"
~d1.roles = 
~d2.{ role = kubespray_defaults }
~d2.{ role = kubernetes/preinstall, when: "dns_mode != 'none' and resolvconf_mode == 'host_resolvconf'", tags: resolvconf, dns_late: true }
