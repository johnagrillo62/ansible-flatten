[0].name = Stop if legacy encapsulation variables are detected (ipip)
[0].assert.that[0] = ipip is not defined
[0].assert.msg = 'ipip' configuration variable is deprecated, please configure your inventory with 'calico_ipip_mode' set to 'Always' or 'CrossSubnet' according to your specific needs
[0].run_once = true
[0].delegate_to = {{ groups['kube_control_plane'][0] }}
[1].name = Stop if legacy encapsulation variables are detected (ipip_mode)
[1].assert.that[0] = ipip_mode is not defined
[1].assert.msg = 'ipip_mode' configuration variable is deprecated, please configure your inventory with 'calico_ipip_mode' set to 'Always' or 'CrossSubnet' according to your specific needs
[1].run_once = true
[1].delegate_to = {{ groups['kube_control_plane'][0] }}
[2].name = Stop if legacy encapsulation variables are detected (calcio_ipam_autoallocateblocks)
[2].assert.that[0] = calcio_ipam_autoallocateblocks is not defined
[2].assert.msg = 'calcio_ipam_autoallocateblocks' configuration variable is deprecated, it's a typo, please configure your inventory with 'calico_ipam_autoallocateblocks' set to 'true' or 'false' according to your specific needs
[2].run_once = true
[2].delegate_to = {{ groups['kube_control_plane'][0] }}
[3].name = Stop if supported Calico versions
[3].assert.that[0] = calico_version in calico_crds_checksums.no_arch.keys()
[3].assert.msg = Calico version not supported {{ calico_version }} not in {{ calico_crds_checksums.no_arch.keys() }}
[3].run_once = true
[3].delegate_to = {{ groups['kube_control_plane'][0] }}
[4].name = Check if calicoctl.sh exists
[4].stat.path = {{ bin_dir }}/calicoctl.sh
[4].register = calicoctl_sh_exists
[4].run_once = true
[4].delegate_to = {{ groups['kube_control_plane'][0] }}
[5].name = Check if calico ready
[5].command = {{ bin_dir }}/calicoctl.sh get ClusterInformation default
[5].register = calico_ready
[5].run_once = true
[5].ignore_errors = true
[5].retries = 5
[5].delay = 10
[5].until = calico_ready.rc == 0
[5].delegate_to = {{ groups['kube_control_plane'][0] }}
[5].when = calicoctl_sh_exists.stat.exists
[6].name = Check that current calico version is enough for upgrade
[6].run_once = true
[6].delegate_to = {{ groups['kube_control_plane'][0] }}
[6].when = calicoctl_sh_exists.stat.exists and calico_ready.rc == 0
[6].block[0].name = Get current calico version
[6].block[0].shell = set -o pipefail && {{ bin_dir }}/calicoctl.sh version | grep 'Client Version:' | awk '{ print $3}'
[6].block[0].args.executable = /bin/bash
[6].block[0].register = calico_version_on_server
[6].block[0].changed_when = false
[6].block[0].check_mode = false
[6].block[1].name = Assert that current calico version is enough for upgrade
[6].block[1].assert.that[0] = calico_version_on_server.stdout.removeprefix('v') is version(calico_min_version_required, '>=')
[6].block[1].assert.msg = Your version of calico is not fresh enough for upgrade. Minimum version is {{ calico_min_version_required }} supported by the previous kubespray release. But current version is {{ calico_version_on_server.stdout }}.

[7].name = Check that cluster_id is set and a valid IPv4 address if calico_rr enabled
[7].assert.that[0] = cluster_id is defined
[7].assert.that[1] = cluster_id is ansible.utils.ipv4
[7].assert.msg = A unique cluster_id is required if using calico_rr, and it must be a valid IPv4 address
[7].when[0] = peer_with_calico_rr
[7].when[1] = inventory_hostname == groups['kube_control_plane'][0]
[7].run_once = true
[7].delegate_to = {{ groups['kube_control_plane'][0] }}
[8].name = Check that calico_rr nodes are in k8s_cluster group
[8].assert.that[0] = "k8s_cluster" in group_names
[8].assert.msg = calico_rr must be a child group of k8s_cluster group
[8].when[0] = "calico_rr" in group_names
[8].run_once = true
[8].delegate_to = {{ groups['kube_control_plane'][0] }}
[9].name = Check vars defined correctly
[9].assert.that[0] = calico_pool_name is defined
[9].assert.that[1] = calico_pool_name is match('^[a-zA-Z0-9-_\\.]{2,63}$')
[9].assert.msg = calico_pool_name contains invalid characters
[9].run_once = true
[9].delegate_to = {{ groups['kube_control_plane'][0] }}
[10].name = Check calico network backend defined correctly
[10].assert.that[0] = calico_network_backend in ['bird', 'vxlan', 'none']
[10].assert.msg = calico network backend is not 'bird', 'vxlan' or 'none'
[10].run_once = true
[10].delegate_to = {{ groups['kube_control_plane'][0] }}
[11].name = Check ipip and vxlan mode defined correctly
[11].run_once = true
[11].delegate_to = {{ groups['kube_control_plane'][0] }}
[11].assert.that[0] = calico_ipip_mode in ['Always', 'CrossSubnet', 'Never']
[11].assert.that[1] = calico_vxlan_mode in ['Always', 'CrossSubnet', 'Never']
[11].assert.msg = calico inter host encapsulation mode is not 'Always', 'CrossSubnet' or 'Never'
[12].name = Check ipip and vxlan mode if simultaneously enabled
[12].assert.that[0] = calico_vxlan_mode in ['Never']
[12].assert.msg = IP in IP and VXLAN mode is mutualy exclusive modes
[12].when[0] = calico_ipip_mode in ['Always', 'CrossSubnet']
[12].run_once = true
[12].delegate_to = {{ groups['kube_control_plane'][0] }}
[13].name = Check ipip and vxlan mode if simultaneously enabled
[13].assert.that[0] = calico_ipip_mode in ['Never']
[13].assert.msg = IP in IP and VXLAN mode is mutualy exclusive modes
[13].when[0] = calico_vxlan_mode in ['Always', 'CrossSubnet']
[13].run_once = true
[13].delegate_to = {{ groups['kube_control_plane'][0] }}
[14].name = Get Calico {{ calico_pool_name }} configuration
[14].command = {{ bin_dir }}/calicoctl.sh get ipPool {{ calico_pool_name }} -o json
[14].failed_when = false
[14].changed_when = false
[14].check_mode = false
[14].register = calico
[14].run_once = true
[14].when = ipv4_stack | bool
[14].delegate_to = {{ groups['kube_control_plane'][0] }}
[15].name = Set calico_pool_conf
[15].set_fact.calico_pool_conf = {{ calico.stdout | from_json }}
[15].when[0] = ipv4_stack | bool
[15].when[1] = calico is defined
[15].when[2] = calico.rc == 0 and calico.stdout
[15].run_once = true
[15].delegate_to = {{ groups['kube_control_plane'][0] }}
[16].name = Check if inventory match current cluster configuration
[16].assert.that[0] = calico_pool_conf.spec.blockSize | int == calico_pool_blocksize | int
[16].assert.that[1] = calico_pool_conf.spec.cidr == (calico_pool_cidr | default(kube_pods_subnet))
[16].assert.that[2] = not calico_pool_conf.spec.ipipMode is defined or calico_pool_conf.spec.ipipMode == calico_ipip_mode
[16].assert.that[3] = not calico_pool_conf.spec.vxlanMode is defined or calico_pool_conf.spec.vxlanMode == calico_vxlan_mode
[16].assert.msg = Your inventory doesn't match the current cluster configuration
[16].when[0] = ipv4_stack | bool
[16].when[1] = calico_pool_conf is defined
[16].run_once = true
[16].delegate_to = {{ groups['kube_control_plane'][0] }}
[17].name = Get Calico {{ calico_pool_name }}-ipv6 configuration
[17].command = {{ bin_dir }}/calicoctl.sh get ipPool {{ calico_pool_name }}-ipv6 -o json
[17].failed_when = false
[17].changed_when = false
[17].check_mode = false
[17].register = calico_ipv6
[17].run_once = true
[17].when = ipv6_stack | bool
[17].delegate_to = {{ groups['kube_control_plane'][0] }}
[18].name = Set calico_pool_ipv6_conf
[18].set_fact.calico_pool_conf = {{ calico_ipv6.stdout | from_json }}
[18].when[0] = ipv6_stack | bool
[18].when[1] = alico_ipv6 is defined
[18].when[2] = calico_ipv6.rc == 0 and calico_ipv6.stdout
[18].run_once = true
[18].delegate_to = {{ groups['kube_control_plane'][0] }}
[19].name = Check if ipv6 inventory match current cluster configuration
[19].assert.that[0] = calico_pool_conf.spec.blockSize | int == calico_pool_blocksize_ipv6 | int
[19].assert.that[1] = calico_pool_conf.spec.cidr == (calico_pool_cidr_ipv6 | default(kube_pods_subnet_ipv6))
[19].assert.that[2] = not calico_pool_conf.spec.ipipMode is defined or calico_pool_conf.spec.ipipMode == calico_ipip_mode_ipv6
[19].assert.that[3] = not calico_pool_conf.spec.vxlanMode is defined or calico_pool_conf.spec.vxlanMode == calico_vxlan_mode_ipv6
[19].assert.msg = Your ipv6 inventory doesn't match the current cluster configuration
[19].when[0] = ipv6_stack | bool
[19].when[1] = calico_pool_ipv6_conf is defined
[19].run_once = true
[19].delegate_to = {{ groups['kube_control_plane'][0] }}
[20].name = Check kdd calico_datastore if calico_apiserver_enabled
[20].assert.that = calico_datastore == "kdd"
[20].assert.msg = When using calico apiserver you need to use the kubernetes datastore
[20].when[0] = calico_apiserver_enabled
[20].run_once = true
[20].delegate_to = {{ groups['kube_control_plane'][0] }}
[21].name = Check kdd calico_datastore if typha_enabled
[21].assert.that = calico_datastore == "kdd"
[21].assert.msg = When using typha you need to use the kubernetes datastore
[21].when[0] = typha_enabled
[21].run_once = true
[21].delegate_to = {{ groups['kube_control_plane'][0] }}
[22].name = Check ipip mode is Never for calico ipv6
[22].assert.that[0] = calico_ipip_mode_ipv6 in ['Never']
[22].assert.msg = Calico doesn't support ipip tunneling for the IPv6
[22].when = ipv6_stack | bool
[22].run_once = true
[22].delegate_to = {{ groups['kube_control_plane'][0] }}
