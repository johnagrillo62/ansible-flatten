[0].name = Check kubelet serving certificates approved with kubelet_csr_approver
[0].when[0] = kubelet_rotate_server_certificates | default(false)
[0].when[1] = kubelet_csr_approver_enabled | default(kubelet_rotate_server_certificates | default(false))
[0].vars.csrs = {{ csr_json.stdout | from_json }}
[0].block[0].name = Get certificate signing requests
[0].block[0].command = {{ bin_dir }}/kubectl get csr -o jsonpath-as-json={.items[*]}
[0].block[0].register = csr_json
[0].block[0].changed_when = false
[0].block[1].name = Check there are csrs
[0].block[1].assert.that = csrs | length > 0
[0].block[1].assert.fail_msg = kubelet_rotate_server_certificates is {{ kubelet_rotate_server_certificates }} but no csr's found
[0].block[2].name = Check there are Denied/Pending csrs
[0].block[2].assert.that[0] = csrs | rejectattr('status') | length == 0
[0].block[2].assert.that[1] = csrs | map(attribute='status.conditions') | flatten | selectattr('type', 'equalto', 'Denied') | length == 0
[0].block[2].assert.fail_msg = kubelet_csr_approver is enabled but CSRs are not approved
[1].name = Approve kubelet serving certificates
[1].when[0] = kubelet_rotate_server_certificates | default(false)
[1].when[1] = not (kubelet_csr_approver_enabled | default(kubelet_rotate_server_certificates | default(false)))
[1].block[0].name = Get certificate signing requests
[1].block[0].command = {{ bin_dir }}/kubectl get csr -o name
[1].block[0].register = get_csr
[1].block[0].changed_when = false
[1].block[1].name = Check there are csrs
[1].block[1].assert.that = get_csr.stdout_lines | length > 0
[1].block[1].assert.fail_msg = kubelet_rotate_server_certificates is {{ kubelet_rotate_server_certificates }} but no csr's found
[1].block[2].name = Approve certificates
[1].block[2].command = {{ bin_dir }}/kubectl certificate approve {{ get_csr.stdout_lines | join(' ') }}
[1].block[2].register = certificate_approve
[1].block[2].when = get_csr.stdout_lines | length > 0
[1].block[2].changed_when = certificate_approve.stdout
[2].name = Create test namespace
[2].command = {{ bin_dir }}/kubectl create namespace test
[2].changed_when = false
[3].name = Run 2 agnhost pods in test ns
[3].command.cmd = {{ bin_dir }}/kubectl apply --namespace test -f -
[3].command.stdin = apiVersion: apps/v1
kind: Deployment
metadata:
  name: agnhost
spec:
  replicas: 2
  selector:
    matchLabels:
      app: agnhost
  template:
    metadata:
      labels:
        app: agnhost
    spec:
      containers:
      - name: agnhost
        image: {{ test_image_repo }}:{{ test_image_tag }}
        command: ['/agnhost', 'netexec', '--http-port=8080']
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop: ['ALL']
          runAsUser: 1000
          runAsNonRoot: true
          seccompProfile:
            type: RuntimeDefault

[3].changed_when = false
[4].name = Check that all pods are running and ready
[4].vars.pods = {{ (pods_json.stdout | from_json)['items'] }}
[4].block[0].name = Check Deployment is ready
[4].block[0].command = {{ bin_dir }}/kubectl rollout status deploy --namespace test agnhost --timeout=180s
[4].block[0].changed_when = false
[4].block[1].name = Get pod names
[4].block[1].command = {{ bin_dir }}/kubectl get pods -n test -o json
[4].block[1].changed_when = false
[4].block[1].register = pods_json
[4].block[2].name = Check pods IP are in correct network
[4].block[2].assert.that = pods | selectattr('status.phase', '==', 'Running') | selectattr('status.podIP', 'ansible.utils.in_network', kube_pods_subnet) | length == 2
[4].block[3].name = Curl between pods is working
[4].block[3].command = {{ bin_dir }}/kubectl -n test exec {{ item[0].metadata.name }} -- curl {{ item[1].status.podIP | ansible.utils.ipwrap}}:8080
[4].block[3].with_nested[0] = {{ pods }}
[4].block[3].with_nested[1] = {{ pods }}
[4].block[3].loop_control.label = {{ item[0].metadata.name + ' --> ' + item[1].metadata.name }}
[4].rescue[0].name = List pods cluster-wide
[4].rescue[0].command = {{ bin_dir }}/kubectl get pods --all-namespaces -owide
[4].rescue[0].changed_when = false
[4].rescue[1].import_role.name = cluster-dump
[4].rescue[2].fail = null
