[0].name = Fail if removed variables are used
[0].vars.removed_vars[0] = kubelet_static_pod_path
[0].vars.removed_vars_found = {{ query('varnames', '^' + (removed_vars | join('|')) + '$') }}
[0].assert.that = removed_vars_found | length == 0
[0].assert.fail_msg = Removed variables present: {{ removed_vars_found | join(', ') }}
[0].run_once = true
[1].name = Stop if kube_control_plane group is empty
[1].assert.that = groups.get( 'kube_control_plane' )
[1].run_once = true
[1].when = not ignore_assert_errors
[2].name = Stop if etcd group is empty in external etcd mode
[2].assert.that = groups.get('etcd') or etcd_deployment_type == 'kubeadm'
[2].assert.fail_msg = Group 'etcd' cannot be empty in external etcd mode
[2].run_once = true
[2].when[0] = not ignore_assert_errors
[3].name = Warn if `kube_network_plugin` is `none`
[3].debug.msg = "WARNING! => `kube_network_plugin` is set to `none`. The network configuration will be skipped.
The cluster won't be ready to use, we recommend to select one of the available plugins"

[3].when[0] = kube_network_plugin == 'none'
[4].name = Stop if unsupported version of Kubernetes
[4].assert.that = kube_version is version(kube_version_min_required, '>=')
[4].assert.msg = The current release of Kubespray only support newer version of Kubernetes than {{ kube_version_min_required }} - You are trying to apply {{ kube_version }}
[4].when = not ignore_assert_errors
[5].name = Stop if known booleans are set as strings (Use JSON format on CLI: -e "{'key': true }")
[5].assert.that[0] = download_run_once | type_debug == 'bool'
[5].assert.that[1] = deploy_netchecker | type_debug == 'bool'
[5].assert.that[2] = download_always_pull | type_debug == 'bool'
[5].assert.that[3] = helm_enabled | type_debug == 'bool'
[5].assert.that[4] = openstack_lbaas_enabled | type_debug == 'bool'
[5].run_once = true
[5].when = not ignore_assert_errors
[6].name = Stop if even number of etcd hosts
[6].assert.that = groups.get('etcd', groups.kube_control_plane) | length is not divisibleby 2
[6].run_once = true
[6].when[0] = not ignore_assert_errors
[7].name = Guarantee that enough network address space is available for all pods
[7].assert.that = {{ (kubelet_max_pods | default(110)) | int <= (2 ** (32 - kube_network_node_prefix | int)) - 2 }}
[7].assert.msg = Do not schedule more pods on a node than inet addresses are available.
[7].when[0] = not ignore_assert_errors
[7].when[1] = ('k8s_cluster' in group_names)
[7].when[2] = kube_network_plugin not in ['calico', 'none']
[7].when[3] = ipv4_stack | bool
[8].name = Check cloud_provider value
[8].assert.that = cloud_provider == 'external'
[8].when[0] = cloud_provider
[8].when[1] = not ignore_assert_errors
[9].name = Check external_cloud_provider value
[9].assert.that = external_cloud_provider in ['hcloud', 'huaweicloud', 'oci', 'openstack', 'vsphere', 'manual']
[9].when[0] = cloud_provider == 'external'
[9].when[1] = not ignore_assert_errors
[10].name = Check that kube_service_addresses is a network range
[10].assert.that[0] = kube_service_addresses | ansible.utils.ipaddr('net')
[10].assert.msg = kube_service_addresses = '{{ kube_service_addresses }}' is not a valid network range
[10].run_once = true
[10].when = ipv4_stack | bool
[11].name = Check that kube_pods_subnet is a network range
[11].assert.that[0] = kube_pods_subnet | ansible.utils.ipaddr('net')
[11].assert.msg = kube_pods_subnet = '{{ kube_pods_subnet }}' is not a valid network range
[11].run_once = true
[11].when = ipv4_stack | bool
[12].name = Check that kube_pods_subnet does not collide with kube_service_addresses
[12].assert.that[0] = kube_pods_subnet | ansible.utils.ipaddr(kube_service_addresses) | string == 'None'
[12].assert.msg = kube_pods_subnet cannot be the same network segment as kube_service_addresses
[12].run_once = true
[12].when = ipv4_stack | bool
[13].name = Check that ipv4 IP range is enough for the nodes
[13].assert.that[0] = 2 ** (kube_network_node_prefix - kube_pods_subnet | ansible.utils.ipaddr('prefix')) >= groups['k8s_cluster'] | length
[13].assert.msg = Not enough ipv4 IPs are available for the desired node count.
[13].when[0] = ipv4_stack | bool
[13].when[1] = kube_network_plugin != 'calico'
[13].run_once = true
[14].name = Check that kube_service_addresses_ipv6 is a network range
[14].assert.that[0] = kube_service_addresses_ipv6 | ansible.utils.ipaddr('net')
[14].assert.msg = kube_service_addresses_ipv6 = '{{ kube_service_addresses_ipv6 }}' is not a valid network range
[14].run_once = true
[14].when = ipv6_stack | bool
[15].name = Check that kube_pods_subnet_ipv6 is a network range
[15].assert.that[0] = kube_pods_subnet_ipv6 | ansible.utils.ipaddr('net')
[15].assert.msg = kube_pods_subnet_ipv6 = '{{ kube_pods_subnet_ipv6 }}' is not a valid network range
[15].run_once = true
[15].when = ipv6_stack | bool
[16].name = Check that kube_pods_subnet_ipv6 does not collide with kube_service_addresses_ipv6
[16].assert.that[0] = kube_pods_subnet_ipv6 | ansible.utils.ipaddr(kube_service_addresses_ipv6) | string == 'None'
[16].assert.msg = kube_pods_subnet_ipv6 cannot be the same network segment as kube_service_addresses_ipv6
[16].run_once = true
[16].when = ipv6_stack | bool
[17].name = Check that ipv6 IP range is enough for the nodes
[17].assert.that[0] = 2 ** (kube_network_node_prefix_ipv6 - kube_pods_subnet_ipv6 | ansible.utils.ipaddr('prefix')) >= groups['k8s_cluster'] | length
[17].assert.msg = Not enough ipv6 IPs are available for the desired node count.
[17].when[0] = ipv6_stack | bool
[17].when[1] = kube_network_plugin != 'calico'
[17].run_once = true
[18].name = Stop if unsupported options selected
[18].assert.that[0] = kube_network_plugin in ['calico', 'flannel', 'cloud', 'cilium', 'cni', 'kube-ovn', 'kube-router', 'macvlan', 'custom_cni', 'none']
[18].assert.that[1] = dns_mode in ['coredns', 'coredns_dual', 'manual', 'none']
[18].assert.that[2] = kube_proxy_mode in ['iptables', 'ipvs', 'nftables']
[18].assert.that[3] = cert_management in ['script', 'none']
[18].assert.that[4] = resolvconf_mode in ['docker_dns', 'host_resolvconf', 'none']
[18].assert.that[5] = etcd_deployment_type in ['host', 'docker', 'kubeadm']
[18].assert.that[6] = etcd_deployment_type in ['host', 'kubeadm'] or container_manager == 'docker'
[18].assert.that[7] = container_manager in ['docker', 'crio', 'containerd']
[18].assert.msg = The selected choice is not supported
[18].run_once = true
[19].name = Warn if `enable_dual_stack_networks` is set
[19].debug.msg = WARNING! => `enable_dual_stack_networks` deprecation. Please switch to using ipv4_stack and ipv6_stack.
[19].when[0] = enable_dual_stack_networks is defined
[20].name = Stop if download_localhost is enabled but download_run_once is not
[20].assert.that = download_run_once
[20].assert.msg = download_localhost requires enable download_run_once
[20].when = download_localhost
[21].name = Stop if kata_containers_enabled is enabled when container_manager is docker
[21].assert.that = container_manager != 'docker'
[21].assert.msg = kata_containers_enabled support only for containerd and crio-o. See https://github.com/kata-containers/documentation/blob/1.11.4/how-to/run-kata-with-k8s.md#install-a-cri-implementation for details
[21].when = kata_containers_enabled
[22].name = Stop if gvisor_enabled is enabled when container_manager is not containerd
[22].assert.that = container_manager == 'containerd'
[22].assert.msg = gvisor_enabled support only compatible with containerd. See https://github.com/kubernetes-sigs/kubespray/issues/7650 for details
[22].when = gvisor_enabled
[23].name = Ensure minimum containerd version
[23].assert.that = containerd_version is version(containerd_min_version_required, '>=')
[23].assert.msg = containerd_version is too low. Minimum version {{ containerd_min_version_required }}
[23].run_once = true
[23].when[0] = containerd_version not in ['latest', 'edge', 'stable']
[23].when[1] = container_manager == 'containerd'
[24].name = Stop if auto_renew_certificates is enabled when certificates are managed externally (kube_external_ca_mode is true)
[24].assert.that = not auto_renew_certificates
[24].assert.msg = Variable auto_renew_certificates must be disabled when CA are managed externally:  kube_external_ca_mode = true
[24].when[0] = kube_external_ca_mode
[24].when[1] = not ignore_assert_errors
