~d0.name = Set device list to process to a single device
~d1.ansible.builtin.set_fact = 
~d2.cryptsetup__process_devices = '{{ [cryptsetup__process_device] }}'
~d1.when = cryptsetup__process_device is defined
~d0.name = Assert that device configuration is valid
~d1.ansible.builtin.assert = 
~d2.that = 
~d1.with_items = '{{ cryptsetup__process_devices | d([]) }}'
~d0.name = Create secrets directory on Ansible controller
~d1.ansible.builtin.file = 
~d2.path = '{{ cryptsetup__secret_path + "/" + item.name }}'
~d2.state = 'directory'
~d2.owner = '{{ cryptsetup__secret_owner }}'
~d2.group = '{{ cryptsetup__secret_group }}'
~d2.mode = '{{ cryptsetup__secret_mode }}'
~d1.become = False
~d1.delegate_to = 'localhost'
~d1.when = (item.state | d(cryptsetup__state) in ['mounted', 'ansible_controller_mounted', 'unmounted', 'present']
~d1.with_items = '{{ cryptsetup__process_devices | d([]) }}'
~d0.name = Generate binary keyfile on the Ansible controller  # noqa no-shorthand
~d1.ansible.builtin.shell = head -c {{ ((512 / 8) if (item.key_size | d(cryptsetup__key_size) == "default")
~d1.args = 
~d2.creates = '{{ item.keyfile | d(cryptsetup__secret_path + "/" + item.name + "/keyfile.raw") }}'
~d1.become = False
~d1.delegate_to = 'localhost'
~d1.register = cryptsetup__register_keyfile_gen
~d1.when = (item.state | d(cryptsetup__state) in ['mounted', 'ansible_controller_mounted', 'unmounted', 'present'] and
~d1.with_items = '{{ cryptsetup__process_devices | d([]) }}'
~d0.name = Generate text/passphrase keyfile on the Ansible controller
~d1.ansible.builtin.shell = 'set -o nounset -o pipefail -o errexit &&
~d1.args = 
~d2.executable = 'bash'
~d2.creates = '{{ item.keyfile | d(cryptsetup__secret_path + "/" + item.name + "/keyfile.raw") }}'
~d1.become = False
~d1.delegate_to = 'localhost'
~d1.register = cryptsetup__register_keyfile_gen
~d1.when = (item.state | d(cryptsetup__state) in ['mounted', 'ansible_controller_mounted', 'unmounted', 'present'] and
~d1.with_items = '{{ cryptsetup__process_devices | d([]) }}'
~d0.name = Enforce permissions of the keyfile on the Ansible controller
~d1.tags = [ 'role::cryptsetup:backup' ]
~d1.ansible.builtin.file = 
~d2.path = '{{ item.keyfile | d(cryptsetup__secret_path + "/" + item.name + "/keyfile.raw") }}'
~d2.owner = '{{ cryptsetup__secret_owner }}'
~d2.group = '{{ cryptsetup__secret_group }}'
~d2.mode = '{{ cryptsetup__secret_mode }}'
~d1.become = False
~d1.delegate_to = 'localhost'
~d1.when = (item.state | d(cryptsetup__state) in ['mounted', 'ansible_controller_mounted', 'unmounted', 'present']
~d1.with_items = '{{ cryptsetup__process_devices | d([]) }}'
~d0.name = Copy keyfiles to remote system
~d1.ansible.builtin.copy = 
~d2.dest = '{{ ("/dev/shm"
~d2.backup = '{{ item.keyfile_backup | d(omit) }}'
~d2.follow = '{{ item.keyfile_follow | d(omit) }}'
~d2.force = '{{ item.keyfile_force | d(omit) }}'
~d2.group = '{{ item.keyfile_group | d(cryptsetup__keyfile_group) }}'
~d2.mode = '{{ item.keyfile_mode | d(cryptsetup__keyfile_mode) }}'
~d2.owner = '{{ item.keyfile_owner | d(cryptsetup__keyfile_owner) }}'
~d2.selevel = '{{ item.keyfile_selevel | d(omit) }}'
~d2.serole = '{{ item.keyfile_serole | d(omit) }}'
~d2.setype = '{{ item.keyfile_setype | d(omit) }}'
~d2.seuser = '{{ item.keyfile_seuser | d(omit) }}'
~d2.src = '{{ item.keyfile | d(cryptsetup__secret_path + "/" + item.name + "/keyfile.raw") }}'
~d2.validate = '{{ item.keyfile_validate | d(omit) }}'
~d1.when = (item.state | d(cryptsetup__state) in ['mounted', 'ansible_controller_mounted', 'unmounted', 'present']
~d1.with_items = '{{ cryptsetup__process_devices | d([]) }}'
~d1.no_log = '{{ debops__no_log | d(True) }}'
~d0.name = Check if ciphertext block device exists
~d1.ansible.builtin.stat = 
~d2.path = '{{ item.ciphertext_block_device }}'
~d2.get_checksum = False
~d1.register = cryptsetup__register_ciphertext_device
~d1.when = (item.state | d(cryptsetup__state) in
~d1.with_items = '{{ cryptsetup__process_devices | d([]) }}'
~d1.tags = [ 'role::cryptsetup:backup' ]
~d0.name = Fail when ciphertext block device does not exist but the state requires for it to exist
~d1.ansible.builtin.fail = 
~d2.msg = |
~d1.when = (item.0.state | d(cryptsetup__state) in
~d1.with_together = 
~d0.name = Fail when ciphertext block device does not exist but the keyfile has changed
~d1.ansible.builtin.fail = # noqa no-handler
~d2.msg = |
~d1.when = (item.0.state | d(cryptsetup__state) in
~d1.with_together = 
~d0.name = Create encryption layer  # noqa no-shorthand
~d1.ansible.builtin.shell = set -o nounset -o pipefail -o errexit &&
~d1.args = 
~d2.executable = 'bash'
~d1.register = cryptsetup__register_cmd
~d1.changed_when = ("Command successful." == cryptsetup__register_cmd.stdout)
~d1.when = (item.0.state | d(cryptsetup__state) in
~d1.with_together = 
~d0.name = Get UUID for ciphertext block device
~d1.ansible.builtin.command = blkid -s UUID -o value "{{ item.0.ciphertext_block_device }}"
~d1.register = cryptsetup__register_ciphertext_blkid
~d1.changed_when = False
~d1.failed_when = (cryptsetup__register_ciphertext_blkid.rc not in [0, 2])
~d1.check_mode = False
~d1.when = (item.0.state | d(cryptsetup__state) in
~d1.with_together = 
~d0.name = Ensure ciphertext block device is configured in crypttab
~d1.community.general.crypttab = 
~d2.backing_device = '{{ ("UUID=" + item.1.stdout)
~d2.name = '{{ item.0.name }}'
~d2.opts = '{{ (item.2.crypttab_options | d(cryptsetup__crypttab_options | d([])) | list | sort | unique | join(","))
~d2.password = '{{ item.0.remote_keyfile | d(("/dev/shm"
~d2.path = '{{ item.0.crypttab_path | d(omit) }}'
~d2.state = 'present'
~d1.no_log = '{{ debops__no_log | d(True) }}'
~d1.when = (item.0.state | d(cryptsetup__state) in ['mounted', 'ansible_controller_mounted', 'unmounted', 'present'])
~d1.with_together = 
~d0.name = Start plaintext device mapper target
~d1.ansible.builtin.command = cryptdisks_start "{{ item.0.name }}"
~d1.register = cryptsetup__register_cryptdisks_start
~d1.changed_when = ("(started)" in cryptsetup__register_cryptdisks_start.stdout)
~d1.when = (item.0.state | d(cryptsetup__state) in
~d1.with_together = 
~d0.name = Check if plaintext device mapper target exists
~d1.ansible.builtin.stat = 
~d2.path = '/dev/mapper/{{ item.name }}'
~d1.register = cryptsetup__register_plaintext_device
~d1.when = (item.state | d(cryptsetup__state) in
~d1.with_items = '{{ cryptsetup__process_devices | d([]) }}'
~d0.name = Create filesystem on plaintext device mapper target
~d1.community.general.filesystem = 
~d2.dev = '/dev/mapper/{{ item.0.name }}'
~d2.force = '{{ item.0.format_force | d(omit) }}'
~d2.fstype = '{{ item.0.fstype | d(cryptsetup__fstype) }}'
~d2.opts = '{{ item.0.format_options | d(omit) }}'
~d1.when = (item.1 | d() and item.1.stat | d() and item.1.stat.exists | d() and
~d1.with_together = 
~d0.name = Ensure mount directories exist when manually mounted
~d1.ansible.builtin.file = 
~d2.path = '{{ item.mount | d(cryptsetup__mountpoint_parent_directory + "/" + item.name) }}'
~d2.state = 'directory'
~d2.mode = '0755'
~d1.when = (item.state | d(cryptsetup__state) in ['present'] and (item.manage_filesystem | d(True) | bool))
~d1.with_items = '{{ cryptsetup__process_devices | d([]) }}'
~d0.name = Create LUKS header backup
~d1.tags = [ 'role::cryptsetup:backup' ]
~d1.ansible.builtin.shell = |
~d1.args = 
~d2.executable = 'bash'
~d1.changed_when = False
~d1.when = ((item.0.backup_header | d(cryptsetup__header_backup) | bool) and
~d1.with_together = 
~d0.name = Store the header backup in secret directory on to the Ansible controller
~d1.tags = [ 'role::cryptsetup:backup' ]
~d1.ansible.builtin.fetch = 
~d2.src = '{{ cryptsetup__header_backup_remote_location + "/" + item.0.name + "_header_backup.raw" }}'
~d2.dest = '{{ cryptsetup__secret_path + "/" + item.0.name + "/header_backup.raw" }}'
~d2.fail_on_missing = True
~d2.flat = True
~d1.when = ((item.0.backup_header | d(cryptsetup__header_backup) | bool) and
~d1.with_together = 
~d0.name = Enforce permissions of the header backup on the Ansible controller
~d1.tags = [ 'role::cryptsetup:backup' ]
~d1.ansible.builtin.file = 
~d2.path = '{{ cryptsetup__secret_path + "/" + item.0.name + "/header_backup.raw" }}'
~d2.owner = '{{ cryptsetup__secret_owner }}'
~d2.group = '{{ cryptsetup__secret_group }}'
~d2.mode = '{{ cryptsetup__secret_mode }}'
~d1.become = False
~d1.delegate_to = 'localhost'
~d1.when = ((item.0.backup_header | d(cryptsetup__header_backup) | bool) and
~d1.with_together = 
~d0.name = Manage fstab and mount state of the plaintext device mapper targets
~d1.ansible.posix.mount = 
~d2.src = '/dev/mapper/{{ item.name }}'
~d2.fstype = '{{ item.fstype | d(cryptsetup__fstype) }}'
~d2.name = '{{ item.mount | d(cryptsetup__mountpoint_parent_directory + "/" + item.name) }}'
~d2.opts = '{{ (item.mount_options | d(cryptsetup__mount_options | d([]))) | list | sort | unique | join(",") }}'
~d2.dump = '{{ item.mount_dump | d(omit) }}'
~d2.passno = '{{ item.mount_passno | d(omit) }}'
~d2.fstab = '{{ item.fstab_path | d(cryptsetup__fstab_file) }}'
~d2.state = '{{ "mounted"
~d1.when = ((item.manage_filesystem | d(True) | bool) and not (item.swap | d(False) | bool))
~d1.with_items = '{{ cryptsetup__process_devices | d([]) }}'
~d0.name = Disable swap devices when requested
~d1.ansible.builtin.shell = |
~d1.changed_when = False
~d1.when = ((item.swap | d(False) | bool) and (item.state | d(cryptsetup__state) in ["unmounted", "absent"]))
~d1.with_items = '{{ cryptsetup__process_devices | d([]) }}'
~d0.name = Manage swap devices in fstab
~d1.ansible.posix.mount = 
~d2.src = '{{ "/dev/mapper/" + item.name }}'
~d2.name = 'none'
~d2.fstype = 'swap'
~d2.opts = '{{ ((item.swap_options | d([]) | list) +
~d2.dump = '0'
~d2.passno = '0'
~d2.fstab = '{{ item.fstab_path | d(cryptsetup__fstab_file) }}'
~d2.state = '{{ (item.state | d(cryptsetup__state) == "absent") | ternary("absent", "present") }}'
~d1.register = cryptsetup__register_swap_fstab
~d1.when = item.swap | d(False) | bool
~d1.with_items = '{{ cryptsetup__process_devices | d([]) }}'
~d0.name = Enable swap devices
~d1.ansible.builtin.command = swapon --priority {{ (item.item.priority | d(cryptsetup__swap_priority) | string) | quote }}
~d1.register = cryptsetup__register_swapon
~d1.changed_when = cryptsetup__register_swapon.changed | bool
~d1.when = (item is changed and (item.item.swap | d(False) | bool) and
~d1.with_items = '{{ cryptsetup__register_swap_fstab.results | d([]) }}'  # noqa no-handler
~d0.name = Ensure mount directory is absent
~d1.ansible.builtin.file = 
~d2.path = '{{ item.mount | d(cryptsetup__mountpoint_parent_directory + "/" + item.name) }}'
~d2.state = 'absent'
~d1.when = (item.state | d(cryptsetup__state) in ['absent'])
~d1.with_items = '{{ cryptsetup__process_devices | d([]) }}'
~d0.name = Stop plaintext device mapper target
~d1.ansible.builtin.command = 'cryptdisks_stop "{{ item.0.name }}"'  # noqa no-handler
~d1.register = cryptsetup__register_cryptdisks_stop
~d1.changed_when = ("(stopping)" in cryptsetup__register_cryptdisks_stop.stdout)
~d1.failed_when = (cryptsetup__register_cryptdisks_stop.rc != 0 and not
~d1.when = (item.0.state | d(cryptsetup__state) in ['unmounted', 'absent'] or
~d1.with_together = 
~d0.name = Ensure ciphertext block device is absent in crypttab
~d1.community.general.crypttab = 
~d2.name = '{{ item.name }}'
~d2.path = '{{ item.crypttab_path | d(omit) }}'
~d2.state = 'absent'
~d1.when = (item.state | d(cryptsetup__state) in ['absent'])
~d1.with_items = '{{ cryptsetup__process_devices | d([]) }}'
~d0.name = Check if remote keyfiles are regular files
~d1.ansible.builtin.stat = 
~d2.path = '{{ (item.remote_keyfile | d(("/dev/shm"
~d1.register = cryptsetup__register_stat_remote_keyfile
~d1.when = (item.state | d(cryptsetup__state) in ['ansible_controller_mounted', 'absent'])
~d1.with_items = '{{ cryptsetup__process_devices | d([]) }}'
~d0.name = Ensure keyfile is unaccessible on the remote system
~d1.ansible.builtin.command = '{{ cryptsetup__keyfile_shred_command }}
~d1.args = 
~d2.removes = '{{ item.stat.path }}'
~d1.when = (item.item.state | d(cryptsetup__state) in ['ansible_controller_mounted', 'absent'] and
~d1.with_items = '{{ cryptsetup__register_stat_remote_keyfile.results | d([]) }}'
~d0.name = Ensure header backup is unaccessible on the remote system
~d1.ansible.builtin.command = '{{ cryptsetup__header_backup_shred_command }}
~d1.args = 
~d2.removes = '{{ cryptsetup__header_backup_remote_location + "/" + item.name + "_header_backup.raw" }}'
~d1.when = ((item.state | d(cryptsetup__state) == 'absent' or
~d1.with_items = '{{ cryptsetup__process_devices | d([]) }}'
~d1.tags = [ 'role::cryptsetup:backup' ]
