~d0.name = Setup ssh config to use the bastion
~d1.hosts = localhost
~d1.gather_facts = false
~d1.roles = 
~d2.{ role = kubespray_defaults}
~d2.{ role = bastion-ssh-config, tags: ["localhost", "bastion"]}
~d0.name = Bootstrap hosts OS for Ansible
~d1.hosts = k8s_cluster:etcd:calico_rr
~d1.any_errors_fatal = "{{ any_errors_fatal | default(true) }}"
~d1.gather_facts = false
~d1.vars = 
~d2.ansible_ssh_pipelining = false
~d1.roles = 
~d2.{ role = kubespray_defaults}
~d2.{ role = bootstrap_os, tags: bootstrap_os}
~d0.name = Preinstall
~d1.hosts = k8s_cluster:etcd:calico_rr
~d1.any_errors_fatal = "{{ any_errors_fatal | default(true) }}"
~d1.roles = 
~d2.{ role = kubespray_defaults}
~d2.{ role = kubernetes/preinstall, tags: preinstall }
~d0.name = Handle upgrades to control plane components first to maintain backwards compat.
~d1.hosts = kube_control_plane
~d1.any_errors_fatal = "{{ any_errors_fatal | default(true) }}"
~d1.serial = 1
~d1.roles = 
~d2.{ role = kubespray_defaults}
~d2.{ role = upgrade/pre-upgrade, tags: pre-upgrade }
~d2.{ role = kubernetes/node, tags: node }
~d2.{ role = kubernetes/control-plane, tags: master, upgrade_cluster_setup: true }
~d2.{ role = kubernetes/client, tags: client }
~d2.{ role = kubernetes-apps/cluster_roles, tags: cluster-roles }
~d2.{ role = upgrade/post-upgrade, tags: post-upgrade }
~d0.name = Finally handle worker upgrades, based on given batch size
~d1.hosts = kube_node:!kube_control_plane
~d1.any_errors_fatal = "{{ any_errors_fatal | default(true) }}"
~d1.serial = "{{ serial | default('20%') }}"
~d1.roles = 
~d2.{ role = kubespray_defaults}
~d2.{ role = upgrade/pre-upgrade, tags: pre-upgrade }
~d2.{ role = kubernetes/node, tags: node }
~d2.{ role = upgrade/post-upgrade, tags: post-upgrade }
~d2.{ role = kubespray_defaults}
