[0].name = Import DebOps global handlers
[0]["ansible.builtin.import_role"].name = global_handlers
[1].name = Check if other resolvers are installed
[1].environment.LC_MESSAGES = C
[1]["ansible.builtin.shell"] = set -o nounset -o pipefail -o errexit &&
dpkg --get-selections | grep -w -E '({{ resolved__skip_packages | join("|") }})'
                      | awk '{print $1}' || true

[1].args.executable = /bin/bash
[1].register = resolved__register_resolvers
[1].changed_when = False
[1].failed_when = False
[1].check_mode = False
[2].name = Set resolved deployment state
[2]["ansible.builtin.set_fact"].resolved__fact_service_state = {{ "present"
                                       if (not resolved__register_resolvers.stdout | d())
                                       else "absent" }}
[3].name = Create systemd-resolved configuration directory for fallback
[3]["ansible.builtin.file"].path = /etc/systemd/resolved.conf.d
[3]["ansible.builtin.file"].state = directory
[3]["ansible.builtin.file"].mode = 0755
[3].when[0] = resolved__enabled | bool
[3].when[1] = resolved__fallback_conf != ''
[3].when[2] = resolved__resolv_conf != '/etc/resolv.conf'
[3].when[3] = not (ansible_local.resolved.installed | d()) | bool
[4].name = Save existing nameservers as fallback to ensure connectivity
[4]["ansible.builtin.template"].src = etc/systemd/resolved.conf.d/fallback-dns.conf.j2
[4]["ansible.builtin.template"].dest = {{ "/etc/systemd/resolved.conf.d/" + resolved__fallback_conf }}
[4]["ansible.builtin.template"].mode = 0644
[4].when[0] = resolved__enabled | bool
[4].when[1] = resolved__fallback_conf != ''
[4].when[2] = resolved__resolv_conf != '/etc/resolv.conf'
[4].when[3] = not (ansible_local.resolved.installed | d()) | bool
[5].name = Create systemd-resolved.service configuration directory
[5]["ansible.builtin.file"].path = /etc/systemd/system/systemd-resolved.service.d
[5]["ansible.builtin.file"].state = directory
[5]["ansible.builtin.file"].mode = 0755
[5].when[0] = resolved__enabled | bool
[6].name = Configure synthesis of local hostname by systemd-resolved
[6]["ansible.builtin.template"].src = etc/systemd/system/systemd-resolved.service.d/synthesize-hostname.conf.j2
[6]["ansible.builtin.template"].dest = /etc/systemd/system/systemd-resolved.service.d/synthesize-hostname.conf
[6]["ansible.builtin.template"].mode = 0644
[6].when[0] = resolved__enabled | bool
[6].notify[0] = Reload systemd daemon
[6].notify[1] = Restart systemd-resolved service
[7].name = Install required resolved packages
[7]["ansible.builtin.package"].name = {{ resolved__base_packages + resolved__packages }}
[7]["ansible.builtin.package"].state = present
[7].register = resolved__register_packages
[7].until = resolved__register_packages is succeeded
[7].when = resolved__enabled | bool
[8].name = Enable and start systemd-resolved service
[8]["ansible.builtin.systemd"].name = systemd-resolved.service
[8]["ansible.builtin.systemd"].state = started
[8]["ansible.builtin.systemd"].enabled = True
[8].when = resolved__enabled | bool
[9].name = Make sure that Ansible local facts directory exists
[9]["ansible.builtin.file"].path = /etc/ansible/facts.d
[9]["ansible.builtin.file"].state = directory
[9]["ansible.builtin.file"].mode = 0755
[9].when = resolved__enabled | bool
[10].name = Save resolved local facts
[10]["ansible.builtin.template"].src = etc/ansible/facts.d/resolved.fact.j2
[10]["ansible.builtin.template"].dest = /etc/ansible/facts.d/resolved.fact
[10]["ansible.builtin.template"].mode = 0755
[10].notify[0] = Refresh host facts
[10].when = resolved__enabled | bool
[10].tags[0] = meta::facts
[11].name = Update Ansible facts if they were modified
[11]["ansible.builtin.meta"] = flush_handlers
[12].name = Remove systemd-resolved configuuration if requested
[12]["ansible.builtin.file"].path = /etc/systemd/resolved.conf.d/ansible.conf
[12]["ansible.builtin.file"].state = absent
[12].notify[0] = Restart systemd-resolved service
[12].when = resolved__enabled | bool and resolved__deploy_state == 'absent'
[13].name = Create systemd-resolved configuration directory
[13]["ansible.builtin.file"].path = /etc/systemd/resolved.conf.d
[13]["ansible.builtin.file"].state = directory
[13]["ansible.builtin.file"].mode = 0755
[13].when = resolved__enabled | bool and resolved__deploy_state != 'absent'
[14].name = Generate systemd-resolved configuration
[14]["ansible.builtin.template"].src = etc/systemd/resolved.conf.d/ansible.conf.j2
[14]["ansible.builtin.template"].dest = /etc/systemd/resolved.conf.d/ansible.conf
[14]["ansible.builtin.template"].mode = 0644
[14].notify[0] = Restart systemd-resolved service
[14].when = resolved__enabled | bool and resolved__deploy_state != 'absent'
[15].name = Ensure that /etc/systemd/dnssd/ directory exists
[15]["ansible.builtin.file"].path = /etc/systemd/dnssd
[15]["ansible.builtin.file"].state = directory
[15]["ansible.builtin.file"].mode = 0755
[15].when = resolved__enabled | bool and resolved__dnssd_enabled | bool
[16].name = Remove dnssd units if requested
[16]["ansible.builtin.file"].path = {{ "/etc/systemd/dnssd/" + item.name }}
[16]["ansible.builtin.file"].state = absent
[16].loop = {{ resolved__combined_units | flatten | debops.debops.parse_kv_items }}
[16].loop_control.label = {{ {"name": item.name, "state": item.state | d("present")} }}
[16].notify[0] = Restart systemd-resolved service
[16].when = resolved__enabled | bool and resolved__dnssd_enabled | bool and item.state | d("present") == 'absent'
[17].name = Remove dnssd unit overrides if requested
[17]["ansible.builtin.file"].path = {{ "/etc/systemd/dnssd/" + item.name + ".d" }}
[17]["ansible.builtin.file"].state = absent
[17].loop = {{ resolved__combined_units | flatten | debops.debops.parse_kv_items }}
[17].loop_control.label = {{ {"name": item.name, "state": item.state | d("present")} }}
[17].notify[0] = Restart systemd-resolved service
[17].when = resolved__enabled | bool and resolved__dnssd_enabled | bool and item.state | d("present") == 'absent'
[18].name = Create directories for dnssd units
[18]["ansible.builtin.file"].path = {{ "/etc/systemd/dnssd/" + (item.name | dirname) }}
[18]["ansible.builtin.file"].state = directory
[18]["ansible.builtin.file"].mode = 0755
[18].loop = {{ resolved__combined_units | flatten | debops.debops.parse_kv_items }}
[18].loop_control.label = {{ {"name": item.name, "state": item.state | d("present")} }}
[18].when = resolved__enabled | bool and resolved__dnssd_enabled | bool and item.raw | d() and item.state | d("present") not in ['absent', 'ignore', 'init'] and (item.name | dirname).endswith('.d')
[19].name = Generate dnssd units
[19]["ansible.builtin.template"].src = etc/systemd/dnssd/template.j2
[19]["ansible.builtin.template"].dest = {{ "/etc/systemd/dnssd/" + item.name }}
[19]["ansible.builtin.template"].mode = 0644
[19].loop = {{ resolved__combined_units | flatten | debops.debops.parse_kv_items }}
[19].loop_control.label = {{ {"name": item.name, "state": item.state | d("present")} }}
[19].notify[0] = Restart systemd-resolved service
[19].when = resolved__enabled | bool and resolved__dnssd_enabled | bool and item.raw | d() and item.state | d("present") not in ['absent', 'ignore', 'init']
[20].name = Flush handlers when needed
[20]["ansible.builtin.meta"] = flush_handlers
[21].name = Manage /etc/resolv.conf configuration file
[21]["ansible.builtin.file"].path = /etc/resolv.conf
[21]["ansible.builtin.file"].src = {{ resolved__resolv_conf }}
[21]["ansible.builtin.file"].state = link
[21]["ansible.builtin.file"].force = True
[21].when[0] = resolved__enabled | bool
[21].when[1] = resolved__resolv_conf != '/etc/resolv.conf'
[21].when[2] = (ansible_local.networkd.state | d('disabled')) == 'enabled'
[21].when[3] = (ansible_local.resolved.state | d('disabled')) == 'enabled'
[22].name = Prepare cleanup during package removal
[22]["ansible.builtin.import_role"].name = dpkg_cleanup
[22].vars.dpkg_cleanup__dependent_packages[0] = {{ resolved__dpkg_cleanup__dependent_packages }}
[22].when = resolved__enabled | bool
[22].tags[0] = role::dpkg_cleanup
[22].tags[1] = skip::dpkg_cleanup
[22].tags[2] = role::resolved:dpkg_cleanup
