[0].name = Kubernetes Apps | Wait for kube-apiserver
[0].uri.url = {{ kube_apiserver_endpoint }}/healthz
[0].uri.validate_certs = false
[0].uri.client_cert = {{ kube_apiserver_client_cert }}
[0].uri.client_key = {{ kube_apiserver_client_key }}
[0].register = result
[0].until = result.status == 200
[0].retries = 20
[0].delay = 1
[0].when = inventory_hostname == groups['kube_control_plane'][0]
[1].name = Kubernetes Apps | CoreDNS
[1].command.cmd = {{ kubectl_apply_stdin }}
[1].command.stdin = {{ lookup('template', item) }}
[1].delegate_to = {{ groups['kube_control_plane'][0] }}
[1].run_once = true
[1].loop = {{ coredns_manifests | flatten }}
[1].tags[0] = coredns
[1].vars.clusterIP = {{ skydns_server }}
[1].when[0] = dns_mode in ['coredns', 'coredns_dual']
[1].when[1] = deploy_coredns
[2].name = Kubernetes Apps | CoreDNS Secondary
[2].command.cmd = {{ kubectl_apply_stdin }}
[2].command.stdin = {{ lookup('template', item) }}
[2].delegate_to = {{ groups['kube_control_plane'][0] }}
[2].run_once = true
[2].loop = {{ coredns_manifests | flatten }}
[2].tags[0] = coredns
[2].vars.clusterIP = {{ skydns_server_secondary }}
[2].vars.coredns_ordinal_suffix = -secondary
[2].when[0] = dns_mode == 'coredns_dual'
[2].when[1] = deploy_coredns
[3].name = Kubernetes Apps | nodelocalDNS
[3].command.cmd = {{ kubectl_apply_stdin }}
[3].command.stdin = {{ lookup('template', item) }}
[3].delegate_to = {{ groups['kube_control_plane'][0] }}
[3].run_once = true
[3].loop = {{ nodelocaldns_manifests | flatten }}
[3].when[0] = enable_nodelocaldns
[3].tags[0] = nodelocaldns
[3].tags[1] = coredns
[3].vars.primaryClusterIP = {%- if dns_mode in ['coredns', 'coredns_dual'] -%} {{ skydns_server }} {%- elif dns_mode == 'manual' -%} {{ manual_dns_server }} {%- endif -%}
[3].vars.secondaryclusterIP = {{ skydns_server_secondary }}
[3].vars.forwardTarget = {%- if secondaryclusterIP is defined and dns_mode == 'coredns_dual' -%} {{ primaryClusterIP }} {{ secondaryclusterIP }} {%- else -%} {{ primaryClusterIP }} {%- endif -%}
[3].vars.upstreamForwardTarget = {%- if upstream_dns_servers | length > 0 -%} {{ upstream_dns_servers | join(' ') }} {%- else -%} /etc/resolv.conf {%- endif -%}
[4].name = Kubernetes Apps | Etcd metrics endpoints
[4].command.cmd = {{ kubectl_apply_stdin }}
[4].command.stdin = {{ lookup('template', item) }}
[4].delegate_to = {{ groups['kube_control_plane'][0] }}
[4].run_once = true
[4].loop[0] = etcd_metrics-endpoints.yml.j2
[4].loop[1] = etcd_metrics-service.yml.j2
[4].when = etcd_metrics_port is defined and etcd_metrics_service_labels is defined
[4].tags[0] = etcd_metrics
[5].name = Kubernetes Apps | Netchecker
[5].command.cmd = {{ kubectl_apply_stdin }}
[5].command.stdin = {{ lookup('template', item) }}
[5].delegate_to = {{ groups['kube_control_plane'][0] }}
[5].run_once = true
[5].vars.k8s_namespace = {{ netcheck_namespace }}
[5].when = deploy_netchecker
[5].tags[0] = netchecker
[5].loop[0] = netchecker-ns.yml.j2
[5].loop[1] = netchecker-agent-sa.yml.j2
[5].loop[2] = netchecker-agent-ds.yml.j2
[5].loop[3] = netchecker-agent-hostnet-ds.yml.j2
[5].loop[4] = netchecker-server-sa.yml.j2
[5].loop[5] = netchecker-server-clusterrole.yml.j2
[5].loop[6] = netchecker-server-clusterrolebinding.yml.j2
[5].loop[7] = netchecker-server-deployment.yml.j2
[5].loop[8] = netchecker-server-svc.yml.j2
