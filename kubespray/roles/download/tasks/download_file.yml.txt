~d0.name = "Download_file | download {{ download.dest }}"
~d1.tags = 
~d1.block = 
~d1.name = Prep_download | Set a few facts
~d2.set_fact = 
~d3.download_force_cache = "{{ true if download_run_once else download_force_cache }}"
~d1.name = Download_file | Show url of file to download
~d2.when = unsafe_show_logs | bool
~d2.debug = 
~d3.msg = "{{ download.url }}"
~d2.run_once = "{{ download_run_once }}"
~d1.name = Download_file | Set pathname of cached file
~d2.set_fact = 
~d3.file_path_cached = "{{ download_cache_dir }}/{{ download.dest | basename }}"
~d2.tags = 
~d1.name = Download_file | Create dest directory on node
~d2.file = 
~d3.path = "{{ download.dest | dirname }}"
~d3.owner = "{{ download.owner | default(omit) }}"
~d3.mode = "0755"
~d3.state = directory
~d3.recurse = true
~d1.name = Download_file | Create local cache directory
~d2.file = 
~d3.path = "{{ file_path_cached | dirname }}"
~d3.state = directory
~d3.recurse = true
~d2.delegate_to = localhost
~d2.connection = local
~d2.delegate_facts = false
~d2.run_once = true
~d2.become = false
~d2.when = 
~d2.tags = 
~d1.name = Download_file | Create cache directory on download_delegate host
~d2.file = 
~d3.path = "{{ file_path_cached | dirname }}"
~d3.state = directory
~d3.recurse = true
~d2.delegate_to = "{{ download_delegate }}"
~d2.delegate_facts = false
~d2.run_once = true
~d2.when = 
~d1.name = Download_file | Download item
~d2.get_url = 
~d3.url = "{{ download.url }}"
~d3.dest = "{{ file_path_cached if download_force_cache else download.dest }}"
~d3.owner = "{{ omit if download_localhost else (download.owner | default(omit)) }}"
~d3.mode = "{{ omit if download_localhost else (download.mode | default(omit)) }}"
~d3.checksum = "{{ download.checksum }}"
~d3.validate_certs = "{{ download_validate_certs }}"
~d3.url_username = "{{ download.username | default(omit) }}"
~d3.url_password = "{{ download.password | default(omit) }}"
~d3.force_basic_auth = "{{ download.force_basic_auth | default(omit) }}"
~d3.timeout = "{{ download.timeout | default(omit) }}"
~d2.delegate_to = "{{ download_delegate if download_force_cache else inventory_hostname }}"
~d2.run_once = "{{ download_force_cache }}"
~d2.register = get_url_result
~d2.become = "{{ not download_localhost }}"
~d2.until = "'OK' in get_url_result.msg or
~d2.retries = "{{ download_retries }}"
~d2.delay = "{{ retry_stagger | default(5) }}"
~d2.environment = "{{ proxy_env }}"
~d2.no_log = "{{ not (unsafe_show_logs | bool) }}"
~d1.name = Download_file | Copy file back to ansible host file cache
~d2.ansible.posix.synchronize = 
~d3.src = "{{ file_path_cached }}"
~d3.dest = "{{ file_path_cached }}"
~d3.use_ssh_args = true
~d3.mode = pull
~d2.when = 
~d1.name = Download_file | Copy file from cache to nodes, if it is available
~d2.ansible.posix.synchronize = 
~d3.src = "{{ file_path_cached }}"
~d3.dest = "{{ download.dest }}"
~d3.use_ssh_args = true
~d3.mode = push
~d2.register = get_task
~d2.until = get_task is succeeded
~d2.delay = "{{ retry_stagger | random + 3 }}"
~d2.retries = "{{ download_retries }}"
~d2.when = 
~d1.name = Download_file | Set mode and owner
~d2.file = 
~d3.path = "{{ download.dest }}"
~d3.mode = "{{ download.mode | default(omit) }}"
~d3.owner = "{{ download.owner | default(omit) }}"
~d2.when = 
~d1.name = "Download_file | Extract file archives"
~d2.include_tasks = "extract_file.yml"
