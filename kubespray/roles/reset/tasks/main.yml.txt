~d0.name = Reset | stop services
~d1.service = 
~d2.name = "{{ item }}"
~d2.state = stopped
~d2.enabled = false
~d1.with_items = 
~d1.failed_when = false
~d1.tags = 
~d0.name = Reset | remove services
~d1.file = 
~d2.path = "/etc/systemd/system/{{ item }}"
~d2.state = absent
~d1.with_items = 
~d1.register = services_removed
~d1.tags = 
~d0.name = Reset | Remove Docker
~d1.include_role = 
~d2.name = container-engine/docker
~d2.tasks_from = reset
~d1.when = container_manager == 'docker'
~d1.tags = 
~d0.name = Reset | systemctl daemon-reload  # noqa no-handler
~d1.systemd_service = 
~d2.daemon_reload = true
~d1.when = services_removed.changed
~d0.name = Reset | check if crictl is present
~d1.stat = 
~d2.path = "{{ bin_dir }}/crictl"
~d2.get_attributes = false
~d2.get_checksum = false
~d2.get_mime = false
~d1.register = crictl
~d0.name = Reset | stop all cri containers
~d1.shell = "set -o pipefail && {{ bin_dir }}/crictl ps -q | xargs -r {{ bin_dir }}/crictl -t 60s stop -t {{ cri_stop_containers_grace_period }}"
~d1.args = 
~d2.executable = /bin/bash
~d1.register = remove_all_cri_containers
~d1.retries = 5
~d1.until = remove_all_cri_containers.rc == 0
~d1.delay = 5
~d1.tags = 
~d1.when = 
~d1.ignore_errors = true  # noqa ignore-errors
~d0.name = Reset | force remove all cri containers
~d1.command = "{{ bin_dir }}/crictl rm -a -f"
~d1.register = remove_all_cri_containers
~d1.retries = 5
~d1.until = remove_all_cri_containers.rc == 0
~d1.delay = 5
~d1.tags = 
~d1.when = 
~d1.ignore_errors = true  # noqa ignore-errors
~d0.name = Reset | stop and disable crio service
~d1.service = 
~d2.name = crio
~d2.state = stopped
~d2.enabled = false
~d1.failed_when = false
~d1.tags = [ crio ]
~d1.when = container_manager == "crio"
~d0.name = Reset | forcefully wipe CRI-O's container and image storage
~d1.command = "crio wipe -f"
~d1.failed_when = false
~d1.tags = [ crio ]
~d1.when = container_manager == "crio"
~d0.name = Reset | stop all cri pods
~d1.shell = "set -o pipefail && {{ bin_dir }}/crictl pods -q | xargs -r {{ bin_dir }}/crictl -t 60s stopp"
~d1.args = 
~d2.executable = /bin/bash
~d1.register = remove_all_cri_containers
~d1.retries = 5
~d1.until = remove_all_cri_containers.rc == 0
~d1.delay = 5
~d1.tags = [ containerd ]
~d1.when = 
~d1.ignore_errors = true  # noqa ignore-errors
~d0.name = Reset | force remove all cri pods
~d1.block = 
~d2.name = Reset | force remove all cri pods
~d3.command = "{{ bin_dir }}/crictl rmp -a -f"
~d3.register = remove_all_cri_containers
~d3.retries = 5
~d3.until = remove_all_cri_containers.rc == 0
~d3.delay = 5
~d3.tags = [ containerd ]
~d3.when = 
~d1.rescue = 
~d2.name = Reset | force remove all cri pods (rescue)
~d3.shell = "ip netns list | cut -d' ' -f 1 | xargs -n1 ip netns delete && {{ bin_dir }}/crictl rmp -a -f"
~d3.ignore_errors = true  # noqa ignore-errors
~d3.changed_when = true
~d0.name = Reset | stop containerd and etcd services
~d1.service = 
~d2.name = "{{ item }}"
~d2.state = stopped
~d2.enabled = false
~d1.with_items = 
~d1.failed_when = false
~d1.tags = 
~d0.name = Reset | remove containerd and etcd services
~d1.file = 
~d2.path = "/etc/systemd/system/{{ item }}"
~d2.state = absent
~d1.with_items = 
~d1.register = services_removed_secondary
~d1.tags = 
~d0.name = Reset | systemctl daemon-reload  # noqa no-handler
~d1.systemd_service = 
~d2.daemon_reload = true
~d1.when = services_removed_secondary.changed
~d0.name = Reset | gather mounted kubelet dirs
~d1.shell = set -o pipefail && mount | grep /var/lib/kubelet/ | awk '{print $3}' | tac
~d1.args = 
~d2.executable = /bin/bash
~d1.check_mode = false
~d1.register = mounted_dirs
~d1.failed_when = false
~d1.changed_when = false
~d1.tags = 
~d0.name = Reset | unmount kubelet dirs
~d1.command = umount -f {{ item }}
~d1.with_items = "{{ mounted_dirs.stdout_lines }}"
~d1.register = umount_dir
~d1.when = mounted_dirs
~d1.retries = 4
~d1.until = umount_dir.rc == 0
~d1.delay = 5
~d1.tags = 
~d0.name = Set IPv4 iptables default policies to ACCEPT
~d1.iptables = 
~d2.chain = "{{ item }}"
~d2.policy = ACCEPT
~d1.with_items = 
~d1.when = flush_iptables | bool and ipv4_stack
~d1.tags = 
~d0.name = Flush iptables
~d1.iptables = 
~d2.table = "{{ item }}"
~d2.flush = true
~d1.with_items = 
~d1.when = flush_iptables | bool and ipv4_stack
~d1.tags = 
~d0.name = Delete IPv4 user-defined chains # noqa command-instead-of-module
~d1.command = iptables -X
~d1.when = flush_iptables | bool and ipv4_stack
~d1.tags = 
~d0.name = Set IPv6 ip6tables default policies to ACCEPT
~d1.iptables = 
~d2.chain = "{{ item }}"
~d2.policy = ACCEPT
~d2.ip_version = ipv6
~d1.with_items = 
~d1.when = flush_iptables | bool and ipv6_stack
~d1.tags = 
~d0.name = Flush ip6tables
~d1.iptables = 
~d2.table = "{{ item }}"
~d2.flush = true
~d2.ip_version = ipv6
~d1.with_items = 
~d1.when = flush_iptables | bool and ipv6_stack
~d1.tags = 
~d0.name = Delete IPv6 user-defined chains # noqa command-instead-of-module
~d1.command = ip6tables -X
~d1.when = flush_iptables | bool and ipv6_stack
~d1.tags = 
~d0.name = Clear IPVS virtual server table
~d1.command = "ipvsadm -C"
~d1.ignore_errors = true  # noqa ignore-errors
~d1.when = 
~d0.name = Reset | check kube-ipvs0 network device
~d1.stat = 
~d2.path = /sys/class/net/kube-ipvs0
~d2.get_attributes = false
~d2.get_checksum = false
~d2.get_mime = false
~d1.register = kube_ipvs0
~d0.name = Reset | Remove kube-ipvs0
~d1.command = "ip link del kube-ipvs0"
~d1.when = 
~d0.name = Reset | check nodelocaldns network device
~d1.stat = 
~d2.path = /sys/class/net/nodelocaldns
~d2.get_attributes = false
~d2.get_checksum = false
~d2.get_mime = false
~d1.register = nodelocaldns_device
~d0.name = Reset | Remove nodelocaldns
~d1.command = "ip link del nodelocaldns"
~d1.when = 
~d0.name = Reset | Check whether /var/lib/kubelet directory exists
~d1.stat = 
~d2.path = /var/lib/kubelet
~d2.get_attributes = false
~d2.get_checksum = false
~d2.get_mime = false
~d1.register = var_lib_kubelet_directory
~d0.name = Reset | Find files/dirs with immutable flag in /var/lib/kubelet
~d1.command = lsattr -laR /var/lib/kubelet/
~d1.become = true
~d1.register = var_lib_kubelet_files_dirs_w_attrs
~d1.changed_when = false
~d1.no_log = true
~d1.when = var_lib_kubelet_directory.stat.exists
~d0.name = Reset | Remove immutable flag from files/dirs in /var/lib/kubelet
~d1.file = 
~d2.path = "{{ filedir_path }}"
~d2.state = touch
~d2.attributes = "-i"
~d2.mode = "0644"
~d1.loop = "{{ var_lib_kubelet_files_dirs_w_attrs.stdout_lines | select('search', 'Immutable') | list }}"
~d1.loop_control = 
~d2.loop_var = file_dir_line
~d2.label = "{{ filedir_path }}"
~d1.vars = 
~d2.filedir_path = "{{ file_dir_line.split(' ')[0] }}"
~d1.when = var_lib_kubelet_directory.stat.exists
~d0.name = Reset | delete some files and directories
~d1.file = 
~d2.path = "{{ item }}"
~d2.state = absent
~d1.with_items = 
~d1.ignore_errors = true  # noqa ignore-errors
~d1.tags = 
~d0.name = Reset | remove containerd binary files
~d1.file = 
~d2.path = "{{ containerd_bin_dir }}/{{ item }}"
~d2.state = absent
~d1.with_items = 
~d1.ignore_errors = true  # noqa ignore-errors
~d1.when = container_manager == 'containerd'
~d1.tags = 
~d0.name = Reset | remove dns settings from dhclient.conf
~d1.blockinfile = 
~d2.path = "{{ item }}"
~d2.state = absent
~d2.marker = "# Ansible entries {mark}"
~d1.failed_when = false
~d1.with_items = 
~d1.tags = 
~d0.name = Reset | include file with reset tasks specific to the network_plugin if exists
~d1.include_role = 
~d2.name = "network_plugin/{{ kube_network_plugin }}"
~d2.tasks_from = reset
~d1.when = 
~d1.tags = 
~d0.name = Reset | Restart network
~d1.when = 
~d1.tags = 
~d1.block = 
~d2.name = Gather active network services
~d3.systemd = 
~d4.name = "{{ item }}"
~d3.loop = 
~d3.register = service_status
~d3.changed_when = false
~d3.ignore_errors = true
~d2.name = Restart active network services
~d3.systemd = 
~d4.name = "{{ item }}"
~d4.state = restarted
~d3.loop = "{{ service_status.results | selectattr('status.ActiveState', '==', 'active') | map(attribute='item') }}"
