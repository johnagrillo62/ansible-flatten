[0].name = Set kubeadm_discovery_address
[0].set_fact.kubeadm_discovery_address = {%- if "127.0.0.1" in kube_apiserver_endpoint or "localhost" in kube_apiserver_endpoint -%} {{ first_kube_control_plane_address | ansible.utils.ipwrap }}:{{ kube_apiserver_port }} {%- else -%} {{ kube_apiserver_endpoint | replace("https://", "") }} {%- endif %}
[0].tags[0] = facts
[1].name = Check if kubelet.conf exists
[1].stat.path = {{ kube_config_dir }}/kubelet.conf
[1].stat.get_attributes = false
[1].stat.get_checksum = false
[1].stat.get_mime = false
[1].register = kubelet_conf
[2].name = Check if kubeadm CA cert is accessible
[2].stat.path = {{ kube_cert_dir }}/ca.crt
[2].stat.get_attributes = false
[2].stat.get_checksum = false
[2].stat.get_mime = false
[2].register = kubeadm_ca_stat
[2].delegate_to = {{ groups['kube_control_plane'][0] }}
[2].run_once = true
[3].name = Fetch CA certificate from control plane node
[3].slurp.src = {{ kube_cert_dir }}/ca.crt
[3].register = ca_cert_content
[3].when[0] = kubeadm_ca_stat.stat is defined
[3].when[1] = kubeadm_ca_stat.stat.exists
[3].delegate_to = {{ groups['kube_control_plane'][0] }}
[3].run_once = true
[4].name = Create kubeadm token for joining nodes with 24h expiration (default)
[4].command = {{ bin_dir }}/kubeadm token create
[4].register = temp_token
[4].delegate_to = {{ groups['kube_control_plane'][0] }}
[4].when = kubeadm_token is not defined
[4].changed_when = false
[5].name = Set kubeadm_token to generated token
[5].set_fact.kubeadm_token = {{ temp_token.stdout }}
[5].when = kubeadm_token is not defined
[6].name = Get kubeconfig for join discovery process
[6].command = {{ kubectl }} -n kube-public get cm cluster-info -o jsonpath='{.data.kubeconfig}'
[6].register = kubeconfig_file_discovery
[6].run_once = true
[6].delegate_to = {{ groups['kube_control_plane'] | first }}
[6].when = kubeadm_use_file_discovery
[7].name = Check if discovery kubeconfig exists
[7].stat.path = {{ kube_config_dir }}/cluster-info-discovery-kubeconfig.yaml
[7].register = cluster_info_discovery_kubeconfig
[8].name = Copy discovery kubeconfig
[8].copy.dest = {{ kube_config_dir }}/cluster-info-discovery-kubeconfig.yaml
[8].copy.content = {{ kubeconfig_file_discovery.stdout }}
[8].copy.owner = root
[8].copy.mode = 0644
[8].when[0] = ('kube_control_plane' not in group_names)
[8].when[1] = not kubelet_conf.stat.exists or not cluster_info_discovery_kubeconfig.stat.exists
[8].when[2] = kubeadm_use_file_discovery
[9].name = Create kubeadm client config
[9].template.src = kubeadm-client.conf.j2
[9].template.dest = {{ kube_config_dir }}/kubeadm-client.conf
[9].template.backup = true
[9].template.mode = 0640
[9].template.validate = {{ kubeadm_config_validate_enabled | ternary(bin_dir + '/kubeadm config validate --config %s', omit) }}
[9].when = ('kube_control_plane' not in group_names)
[10].name = Join to cluster if needed
[10].environment.PATH = {{ bin_dir }}:{{ ansible_env.PATH }}:/sbin
[10].when[0] = ('kube_control_plane' not in group_names)
[10].when[1] = not kubelet_conf.stat.exists
[10].vars.ignored[0] = {{ 'DirAvailable--etc-kubernetes-manifests' if 'all' not in kubeadm_ignore_preflight_errors }}
[10].vars.ignored[1] = {{ kubeadm_ignore_preflight_errors }}
[10].command = timeout -k {{ kubeadm_join_timeout }} {{ kubeadm_join_timeout }} {{ bin_dir }}/kubeadm join --config {{ kube_config_dir }}/kubeadm-client.conf --ignore-preflight-errors={{ ignored | select | flatten | join(',') }} --skip-phases={{ kubeadm_join_phases_skip | join(',') }}
[11].name = Update server field in kubelet kubeconfig
[11].lineinfile.dest = {{ kube_config_dir }}/kubelet.conf
[11].lineinfile.regexp = server:
[11].lineinfile.line =     server: {{ kube_apiserver_endpoint }}
[11].lineinfile.backup = true
[11].when[0] = kubeadm_config_api_fqdn is not defined
[11].when[1] = ('kube_control_plane' not in group_names)
[11].when[2] = kubeadm_discovery_address != kube_apiserver_endpoint | replace("https://", "")
[11].notify = Kubeadm | restart kubelet
[12].name = Update server field in kubelet kubeconfig - external lb
[12].lineinfile.dest = {{ kube_config_dir }}/kubelet.conf
[12].lineinfile.regexp = ^    server: https
[12].lineinfile.line =     server: {{ kube_apiserver_endpoint }}
[12].lineinfile.backup = true
[12].when[0] = ('kube_control_plane' not in group_names)
[12].when[1] = loadbalancer_apiserver is defined
[12].notify = Kubeadm | restart kubelet
[13].name = Get current resourceVersion of kube-proxy configmap
[13].command = {{ kubectl }} get configmap kube-proxy -n kube-system -o jsonpath='{.metadata.resourceVersion}'
[13].register = original_configmap_resource_version
[13].run_once = true
[13].delegate_to = {{ groups['kube_control_plane'] | first }}
[13].delegate_facts = false
[13].when[0] = kube_proxy_deployed
[13].tags[0] = kube-proxy
[14].name = Update server field in kube-proxy kubeconfig
[14].shell = set -o pipefail && {{ kubectl }} get configmap kube-proxy -n kube-system -o yaml | sed 's#server:.*#server: https://127.0.0.1:{{ kube_apiserver_port }}#g' | {{ kubectl }} replace -f -
[14].args.executable = /bin/bash
[14].run_once = true
[14].delegate_to = {{ groups['kube_control_plane'] | first }}
[14].delegate_facts = false
[14].when[0] = kubeadm_config_api_fqdn is not defined
[14].when[1] = kubeadm_discovery_address != kube_apiserver_endpoint | replace("https://", "")
[14].when[2] = kube_proxy_deployed
[14].when[3] = loadbalancer_apiserver_localhost
[14].tags[0] = kube-proxy
[15].name = Update server field in kube-proxy kubeconfig - external lb
[15].shell = set -o pipefail && {{ kubectl }} get configmap kube-proxy -n kube-system -o yaml | sed 's#server:.*#server: {{kube_apiserver_endpoint}}#g' | {{ kubectl }} replace -f -
[15].args.executable = /bin/bash
[15].run_once = true
[15].delegate_to = {{ groups['kube_control_plane'] | first }}
[15].delegate_facts = false
[15].when[0] = kube_proxy_deployed
[15].when[1] = loadbalancer_apiserver is defined
[15].tags[0] = kube-proxy
[16].name = Get new resourceVersion of kube-proxy configmap
[16].command = {{ kubectl }} get configmap kube-proxy -n kube-system -o jsonpath='{.metadata.resourceVersion}'
[16].register = new_configmap_resource_version
[16].run_once = true
[16].delegate_to = {{ groups['kube_control_plane'] | first }}
[16].delegate_facts = false
[16].when[0] = kube_proxy_deployed
[16].tags[0] = kube-proxy
[17].name = Set ca.crt file permission
[17].file.path = {{ kube_cert_dir }}/ca.crt
[17].file.owner = root
[17].file.group = root
[17].file.mode = 0644
[18].name = Restart all kube-proxy pods to ensure that they load the new configmap
[18].command = {{ kubectl }} delete pod -n kube-system -l k8s-app=kube-proxy --force --grace-period=0
[18].run_once = true
[18].delegate_to = {{ groups['kube_control_plane'] | first }}
[18].delegate_facts = false
[18].when[0] = kubeadm_config_api_fqdn is not defined or loadbalancer_apiserver is defined
[18].when[1] = kubeadm_discovery_address != kube_apiserver_endpoint | replace("https://", "") or loadbalancer_apiserver is defined
[18].when[2] = kube_proxy_deployed
[18].when[3] = original_configmap_resource_version.stdout != new_configmap_resource_version.stdout
[18].tags[0] = kube-proxy
[19].name = Extract etcd certs from control plane if using etcd kubeadm mode
[19].include_tasks = kubeadm_etcd_node.yml
[19].when[0] = etcd_deployment_type == "kubeadm"
[19].when[1] = inventory_hostname not in groups['kube_control_plane']
[19].when[2] = kube_network_plugin in ["calico", "flannel", "cilium"] or cilium_deploy_additionally
[19].when[3] = kube_network_plugin != "calico" or calico_datastore == "etcd"
[19].when[4] = kube_network_plugin != "cilium" or cilium_identity_allocation_mode != 'crd'
