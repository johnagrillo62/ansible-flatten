[0].name = Common tasks for every playbooks
[0].import_playbook = boilerplate.yml
[1].name = Gather facts
[1].import_playbook = internal_facts.yml
[2].name = Install etcd
[2].vars.etcd_cluster_setup = false
[2].vars.etcd_events_cluster_setup = false
[2].import_playbook = install_etcd.yml
[3].name = Download images to ansible host cache via first kube_control_plane node
[3].hosts = kube_control_plane[0]
[3].gather_facts = false
[3].any_errors_fatal = {{ any_errors_fatal | default(true) }}
[3].environment = {{ proxy_disable_env }}
[3].roles[0].role = kubespray_defaults
[3].roles[0].when = not skip_downloads and download_run_once and not download_localhost
[3].roles[1].role = kubernetes/preinstall
[3].roles[1].tags = preinstall
[3].roles[1].when = not skip_downloads and download_run_once and not download_localhost
[3].roles[2].role = download
[3].roles[2].tags = download
[3].roles[2].when = not skip_downloads and download_run_once and not download_localhost
[4].name = Target only workers to get kubelet installed and checking in on any new nodes(engine)
[4].hosts = kube_node
[4].gather_facts = false
[4].any_errors_fatal = {{ any_errors_fatal | default(true) }}
[4].environment = {{ proxy_disable_env }}
[4].roles[0].role = kubespray_defaults
[4].roles[1].role = kubernetes/preinstall
[4].roles[1].tags = preinstall
[4].roles[2].role = container-engine
[4].roles[2].tags = container-engine
[4].roles[2].when = deploy_container_engine
[4].roles[3].role = download
[4].roles[3].tags = download
[4].roles[3].when = not skip_downloads
[4].roles[4].role = etcd
[4].roles[4].tags = etcd
[4].roles[4].vars.etcd_cluster_setup = false
[4].roles[4].when[0] = etcd_deployment_type != "kubeadm"
[4].roles[4].when[1] = kube_network_plugin in ["calico", "flannel", "canal", "cilium"] or cilium_deploy_additionally | default(false) | bool
[4].roles[4].when[2] = kube_network_plugin != "calico" or calico_datastore == "etcd"
[5].name = Target only workers to get kubelet installed and checking in on any new nodes(node)
[5].hosts = kube_node
[5].gather_facts = false
[5].any_errors_fatal = {{ any_errors_fatal | default(true) }}
[5].environment = {{ proxy_disable_env }}
[5].roles[0].role = kubespray_defaults
[5].roles[1].role = kubernetes/node
[5].roles[1].tags = node
[6].name = Upload control plane certs and retrieve encryption key
[6].hosts = kube_control_plane | first
[6].environment = {{ proxy_disable_env }}
[6].gather_facts = false
[6].tags = kubeadm
[6].roles[0].role = kubespray_defaults
[6].tasks[0].name = Upload control plane certificates
[6].tasks[0].command = {{ bin_dir }}/kubeadm init phase --config {{ kube_config_dir }}/kubeadm-config.yaml upload-certs --upload-certs
[6].tasks[0].environment = {{ proxy_disable_env }}
[6].tasks[0].register = kubeadm_upload_cert
[6].tasks[0].changed_when = false
[6].tasks[1].name = Set fact 'kubeadm_certificate_key' for later use
[6].tasks[1].set_fact.kubeadm_certificate_key = {{ kubeadm_upload_cert.stdout_lines[-1] | trim }}
[6].tasks[1].when = kubeadm_certificate_key is not defined
[7].name = Target only workers to get kubelet installed and checking in on any new nodes(network)
[7].hosts = kube_node
[7].gather_facts = false
[7].any_errors_fatal = {{ any_errors_fatal | default(true) }}
[7].environment = {{ proxy_disable_env }}
[7].roles[0].role = kubespray_defaults
[7].roles[1].role = kubernetes/kubeadm
[7].roles[1].tags = kubeadm
[7].roles[2].role = kubernetes/node-label
[7].roles[2].tags = node-label
[7].roles[3].role = kubernetes/node-taint
[7].roles[3].tags = node-taint
[7].roles[4].role = network_plugin
[7].roles[4].tags = network
[8].name = Apply resolv.conf changes now that cluster DNS is up
[8].hosts = k8s_cluster
[8].gather_facts = false
[8].any_errors_fatal = {{ any_errors_fatal | default(true) }}
[8].environment = {{ proxy_disable_env }}
[8].roles[0].role = kubespray_defaults
[8].roles[1].role = kubernetes/preinstall
[8].roles[1].when = dns_mode != 'none' and resolvconf_mode == 'host_resolvconf'
[8].roles[1].tags = resolvconf
[8].roles[1].dns_late = true
