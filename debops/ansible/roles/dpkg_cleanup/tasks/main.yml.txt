[0].name = Ensure that the cleanup script directory exists
[0]["ansible.builtin.file"].path = {{ dpkg_cleanup__scripts_path }}
[0]["ansible.builtin.file"].state = directory
[0]["ansible.builtin.file"].mode = 0755
[0].when = dpkg_cleanup__enabled | bool
[1].name = Remove cleanup scripts if requested
[1]["ansible.builtin.file"].path = {{ dpkg_cleanup__scripts_path + "/" + item.name }}
[1]["ansible.builtin.file"].state = absent
[1].loop = {{ q("flattened", dpkg_cleanup__dependent_packages) }}
[1].loop_control.label = {{ {"package": item.name} }}
[1].when = dpkg_cleanup__enabled | bool and item.name | d() and item.state | d('present') == 'absent'
[2].name = Remove cleanup hooks if requested
[2]["ansible.builtin.file"].path = {{ dpkg_cleanup__hooks_path + "/dpkg-cleanup-" + item.name }}
[2]["ansible.builtin.file"].state = absent
[2].loop = {{ q("flattened", dpkg_cleanup__dependent_packages) }}
[2].loop_control.label = {{ {"package": item.name} }}
[2].when = dpkg_cleanup__enabled | bool and item.name | d() and item.state | d('present') == 'absent'
[3].name = Generate cleanup scripts
[3]["ansible.builtin.template"].src = usr/local/lib/dpkg-cleanup/package.j2
[3]["ansible.builtin.template"].dest = {{ dpkg_cleanup__scripts_path + "/" + item.name }}
[3]["ansible.builtin.template"].mode = 0755
[3].loop = {{ q("flattened", dpkg_cleanup__dependent_packages) }}
[3].loop_control.label = {{ {"package": item.name} }}
[3].when = dpkg_cleanup__enabled | bool and item.name | d() and item.state | d('present') != 'absent'
[4].name = Generate cleanup hooks
[4]["ansible.builtin.template"].src = etc/dpkg/dpkg.cfg.d/dpkg-cleanup-package.j2
[4]["ansible.builtin.template"].dest = {{ dpkg_cleanup__hooks_path + "/dpkg-cleanup-" + item.name }}
[4]["ansible.builtin.template"].mode = 0644
[4].loop = {{ q("flattened", dpkg_cleanup__dependent_packages) }}
[4].loop_control.label = {{ {"package": item.name} }}
[4].when = dpkg_cleanup__enabled | bool and item.name | d() and item.state | d('present') != 'absent'
