~d0.name = Collect debug info
~d1.hosts = all
~d1.become = true
~d1.gather_facts = false
~d1.vars = 
~d2.docker_bin_dir = /usr/bin
~d2.bin_dir = /usr/local/bin
~d2.ansible_ssh_pipelining = true
~d2.etcd_cert_dir = /etc/ssl/etcd/ssl
~d2.kube_network_plugin = calico
~d2.archive_dirname = collect-info
~d2.commands = 
~d3.name = timedate_info
~d4.cmd = timedatectl status
~d3.name = kernel_info
~d4.cmd = uname -r
~d3.name = docker_info
~d4.cmd = "{{ docker_bin_dir }}/docker info"
~d3.name = ip_info
~d4.cmd = ip -4 -o a
~d3.name = route_info
~d4.cmd = ip ro
~d3.name = proc_info
~d4.cmd = ps auxf | grep -v ]$
~d3.name = systemctl_failed_info
~d4.cmd = systemctl --state=failed --no-pager
~d3.name = k8s_info
~d4.cmd = "{{ bin_dir }}/kubectl get all --all-namespaces -o wide"
~d3.name = errors_info
~d4.cmd = journalctl -p err --no-pager
~d3.name = etcd_info
~d4.cmd = "{{ bin_dir }}/etcdctl endpoint --cluster health"
~d3.name = calico_info
~d4.cmd = "{{ bin_dir }}/calicoctl node status"
~d4.when = '{{ kube_network_plugin == "calico" }}'
~d3.name = calico_workload_info
~d4.cmd = "{{ bin_dir }}/calicoctl get workloadEndpoint -o wide"
~d4.when = '{{ kube_network_plugin == "calico" }}'
~d3.name = calico_pool_info
~d4.cmd = "{{ bin_dir }}/calicoctl get ippool -o wide"
~d4.when = '{{ kube_network_plugin == "calico" }}'
~d3.name = kube_describe_all
~d4.cmd = "{{ bin_dir }}/kubectl describe all --all-namespaces"
~d3.name = kube_describe_nodes
~d4.cmd = "{{ bin_dir }}/kubectl describe nodes"
~d3.name = kubelet_logs
~d4.cmd = journalctl -u kubelet --no-pager
~d3.name = coredns_logs
~d4.cmd = "for i in `{{ bin_dir }}/kubectl get pods -n kube-system -l k8s-app=coredns -o jsonpath={.items..metadata.name}`;
~d3.name = apiserver_logs
~d4.cmd = "for i in `{{ bin_dir }}/kubectl get pods -n kube-system -l component=kube-apiserver -o jsonpath={.items..metadata.name}`;
~d3.name = controller_logs
~d4.cmd = "for i in `{{ bin_dir }}/kubectl get pods -n kube-system -l component=kube-controller-manager -o jsonpath={.items..metadata.name}`;
~d3.name = scheduler_logs
~d4.cmd = "for i in `{{ bin_dir }}/kubectl get pods -n kube-system -l component=kube-scheduler -o jsonpath={.items..metadata.name}`;
~d3.name = proxy_logs
~d4.cmd = "for i in `{{ bin_dir }}/kubectl get pods -n kube-system -l k8s-app=kube-proxy -o jsonpath={.items..metadata.name}`;
~d3.name = nginx_logs
~d4.cmd = "for i in `{{ bin_dir }}/kubectl get pods -n kube-system -l k8s-app=kube-nginx -o jsonpath={.items..metadata.name}`;
~d3.name = flannel_logs
~d4.cmd = "for i in `{{ bin_dir }}/kubectl get pods -n kube-system -l app=flannel -o jsonpath={.items..metadata.name}`;
~d4.when = '{{ kube_network_plugin == "flannel" }}'
~d3.name = canal_logs
~d4.cmd = "for i in `{{ bin_dir }}/kubectl get pods -n kube-system -l k8s-app=canal-node -o jsonpath={.items..metadata.name}`;
~d4.when = '{{ kube_network_plugin == "canal" }}'
~d3.name = calico_policy_logs
~d4.cmd = "for i in `{{ bin_dir }}/kubectl get pods -n kube-system -l k8s-app=calico-kube-controllers -o jsonpath={.items..metadata.name}`;
~d4.when = '{{ kube_network_plugin in ["canal", "calico"] }}'
~d3.name = helm_show_releases_history
~d4.cmd = "for i in `{{ bin_dir }}/helm list -q`; do {{ bin_dir }}/helm history ${i} --col-width=0; done"
~d4.when = "{{ helm_enabled | default(true) }}"
~d2.logs = 
~d1.environment = 
~d2.ETCDCTL_API = "3"
~d2.ETCDCTL_CERT = "{{ etcd_cert_dir }}/admin-{{ inventory_hostname }}.pem"
~d2.ETCDCTL_KEY = "{{ etcd_cert_dir }}/admin-{{ inventory_hostname }}-key.pem"
~d2.ETCDCTL_CACERT = "{{ etcd_cert_dir }}/ca.pem"
~d2.ETCDCTL_ENDPOINTS = "{{ etcd_access_addresses }}"
~d1.tasks = 
~d2.name = Set etcd_access_addresses
~d3.set_fact = 
~d4.etcd_access_addresses = |-
~d6.https = //{{ item }}:2379{% if not loop.last %},{% endif %}
~d3.when = "'etcd' in groups"
~d2.name = Storing commands output
~d3.shell = "{{ item.cmd }} &> {{ item.name }}"
~d3.failed_when = false
~d3.with_items = "{{ commands }}"
~d3.when = item.when | default(True)
~d3.no_log = true
~d2.name = Fetch results
~d3.fetch = 
~d4.src = "{{ item.name }}"
~d4.dest = "/tmp/{{ archive_dirname }}/commands"
~d3.with_items = "{{ commands }}"
~d3.when = item.when | default(True)
~d3.failed_when = false
~d2.name = Fetch logs
~d3.fetch = 
~d4.src = "{{ item }}"
~d4.dest = "/tmp/{{ archive_dirname }}/logs"
~d3.with_items = "{{ logs }}"
~d3.failed_when = false
~d2.name = Pack results and logs
~d3.community.general.archive = 
~d4.path = "/tmp/{{ archive_dirname }}"
~d4.dest = "{{ dir | default('.') }}/logs.tar.gz"
~d4.remove = true
~d4.mode = "0640"
~d3.delegate_to = localhost
~d3.connection = local
~d3.become = false
~d3.run_once = true
~d2.name = Clean up collected command outputs
~d3.file = 
~d4.path = "{{ item.name }}"
~d4.state = absent
~d3.with_items = "{{ commands }}"
