libvirtd__kvm_support = {{ True
                           if (ansible_virtualization_type == "kvm" and
                               (ansible_virtualization_role == "host" or
                                libvirtd__register_hw_virt.stdout | d()))
                           else False }}
libvirtd__base_packages[0] = libvirt-daemon-system
libvirtd__base_packages[1] = libvirt-clients
libvirtd__base_packages[2] = libnss-libvirt
libvirtd__base_packages_map.trusty[0] = libvirt-bin
libvirtd__base_packages_map.xenial[0] = libvirt-bin
libvirtd__kvm_packages = {{ ["qemu-system-x86", "qemu-utils"]
                            + (["qemu-kvm"]
                              if ansible_distribution_release in ["stretch",
                                   "buster", "bionic", "focal"]
                              else []) }}
libvirtd__network_packages[0] = dnsmasq-base
libvirtd__network_packages[1] = bridge-utils
libvirtd__network_packages[2] = ebtables
libvirtd__misc_packages[0] = gawk
libvirtd__misc_packages[1] = netcat-openbsd
libvirtd__misc_packages[2] = ovmf
libvirtd__misc_packages[3] = pm-utils
libvirtd__misc_packages[4] = sysfsutils
libvirtd__misc_packages[5] = {{ [] if (ansible_distribution_release in ["bullseye"])
           else "virt-top" }}
libvirtd__version = {{ ansible_local.libvirtd.version | d("0.0.0") }}
libvirtd__deployment_mode = {{ "opennebula"
                               if ("debops_service_opennebula_node" in group_names)
                               else "libvirt" }}
libvirtd__admins = {{ [ansible_user | d(lookup("env", "USER"))]
                      if ansible_user | d(lookup("env", "USER")) != "root"
                      else [] }}
libvirtd__unix_sock_group = {{ ansible_local.libvirtd.unix_sock_group | d("libvirt") }}
libvirtd__system_uri = qemu:///system
libvirtd__uri_aliases.localhost = {{ libvirtd__system_uri }}
libvirtd__default_uri = localhost
libvirtd__original_configuration[0].name = listen_tls
libvirtd__original_configuration[0].comment = Flag listening for secure TLS connections on the public TCP/IP port.
NB, must pass the --listen flag to the libvirtd process for this to
have any effect.

It is necessary to setup a CA and issue server certificates before
using this capability.

This is enabled by default, uncomment this to disable it

libvirtd__original_configuration[0].value = False
libvirtd__original_configuration[0].section = network
libvirtd__original_configuration[0].state = comment
libvirtd__original_configuration[0].weight = 1
libvirtd__original_configuration[1].name = listen_tcp
libvirtd__original_configuration[1].comment = Listen for unencrypted TCP connections on the public TCP/IP port.
NB, must pass the --listen flag to the libvirtd process for this to
have any effect.

Using the TCP socket requires SASL authentication by default. Only
SASL mechanisms which support data encryption are allowed. This is
DIGEST_MD5 and GSSAPI (Kerberos5)

This is disabled by default, uncomment this to enable it.

libvirtd__original_configuration[1].value = True
libvirtd__original_configuration[1].section = network
libvirtd__original_configuration[1].state = comment
libvirtd__original_configuration[1].weight = 2
libvirtd__original_configuration[2].name = tls_port
libvirtd__original_configuration[2].comment = Override the port for accepting secure TLS connections
This can be a port number, or service name

libvirtd__original_configuration[2].value = 16514
libvirtd__original_configuration[2].section = network
libvirtd__original_configuration[2].state = comment
libvirtd__original_configuration[2].weight = 3
libvirtd__original_configuration[3].name = tcp_port
libvirtd__original_configuration[3].comment = Override the port for accepting insecure TCP connections
This can be a port number, or service name

libvirtd__original_configuration[3].value = 16509
libvirtd__original_configuration[3].section = network
libvirtd__original_configuration[3].state = comment
libvirtd__original_configuration[3].weight = 4
libvirtd__original_configuration[4].name = listen_addr
libvirtd__original_configuration[4].comment = Override the default configuration which binds to all network
interfaces. This can be a numeric IPv4/6 address, or hostname

If the libvirtd service is started in parallel with network
startup (e. g. with systemd), binding to addresses other than
the wildcards (0.0.0.0/::) might not be available yet.

libvirtd__original_configuration[4].value = 192.168.0.1
libvirtd__original_configuration[4].section = network
libvirtd__original_configuration[4].state = comment
libvirtd__original_configuration[4].weight = 5
libvirtd__original_configuration[5].name = mdns_adv
libvirtd__original_configuration[5].comment = Flag toggling mDNS advertisement of the libvirt service.

Alternatively can disable for all services on a host by
stopping the Avahi daemon

This is disabled by default, uncomment this to enable it

libvirtd__original_configuration[5].value = True
libvirtd__original_configuration[5].section = network
libvirtd__original_configuration[5].state = comment
libvirtd__original_configuration[5].weight = 6
libvirtd__original_configuration[6].name = mdns_name
libvirtd__original_configuration[6].comment = Override the default mDNS advertisement name. This must be
unique on the immediate broadcast network.

The default is "Virtualization Host HOSTNAME", where HOSTNAME
is substituted for the short hostname of the machine (without domain)

libvirtd__original_configuration[6].value = Virtualization Host Joe Demo
libvirtd__original_configuration[6].section = network
libvirtd__original_configuration[6].state = comment
libvirtd__original_configuration[6].weight = 7
libvirtd__original_configuration[7].name = unix_sock_group
libvirtd__original_configuration[7].comment = Set the UNIX domain socket group ownership. This can be used to
allow a 'trusted' set of users access to management capabilities
without becoming root.

This is restricted to 'root' by default.

libvirtd__original_configuration[7].value = libvirt
libvirtd__original_configuration[7].section = unix-socket
libvirtd__original_configuration[7].state = comment
libvirtd__original_configuration[7].weight = 1
libvirtd__original_configuration[8].name = unix_sock_ro_perms
libvirtd__original_configuration[8].comment = Set the UNIX socket permissions for the R/O socket. This is used
for monitoring VM status only

Default allows any user. If setting group ownership, you may want to
restrict this too.

libvirtd__original_configuration[8].value = 0777
libvirtd__original_configuration[8].section = unix-socket
libvirtd__original_configuration[8].state = comment
libvirtd__original_configuration[8].weight = 2
libvirtd__original_configuration[9].name = unix_sock_rw_perms
libvirtd__original_configuration[9].comment = Set the UNIX socket permissions for the R/W socket. This is used
for full management of VMs

Default allows only root. If PolicyKit is enabled on the socket,
the default will change to allow everyone (eg, 0777)

If not using PolicyKit and setting group ownership for access
control, then you may want to relax this too.

libvirtd__original_configuration[9].value = 0770
libvirtd__original_configuration[9].section = unix-socket
libvirtd__original_configuration[9].state = comment
libvirtd__original_configuration[9].weight = 3
libvirtd__original_configuration[10].name = unix_sock_admin_perms
libvirtd__original_configuration[10].comment = Set the UNIX socket permissions for the admin interface socket.

Default allows only owner (root), do not change it unless you are
sure to whom you are exposing the access to.

libvirtd__original_configuration[10].value = 0700
libvirtd__original_configuration[10].section = unix-socket
libvirtd__original_configuration[10].state = comment
libvirtd__original_configuration[10].weight = 4
libvirtd__original_configuration[11].name = unix_sock_dir
libvirtd__original_configuration[11].comment = Set the name of the directory in which sockets will be found/created.

libvirtd__original_configuration[11].value = /var/run/libvirt
libvirtd__original_configuration[11].section = unix-socket
libvirtd__original_configuration[11].state = comment
libvirtd__original_configuration[11].weight = 5
libvirtd__original_configuration[12].name = auth_unix_ro
libvirtd__original_configuration[12].comment = Set an authentication scheme for UNIX read-only sockets
By default socket permissions allow anyone to connect

To restrict monitoring of domains you may wish to enable
an authentication mechanism here

libvirtd__original_configuration[12].value = none
libvirtd__original_configuration[12].section = authn
libvirtd__original_configuration[12].state = comment
libvirtd__original_configuration[12].weight = 1
libvirtd__original_configuration[13].name = auth_unix_rw
libvirtd__original_configuration[13].comment = Set an authentication scheme for UNIX read-write sockets
By default socket permissions only allow root. If PolicyKit
support was compiled into libvirt, the default will be to
use 'polkit' auth.

If the unix_sock_rw_perms are changed you may wish to enable
an authentication mechanism here

libvirtd__original_configuration[13].value = none
libvirtd__original_configuration[13].section = authn
libvirtd__original_configuration[13].state = comment
libvirtd__original_configuration[13].weight = 2
libvirtd__original_configuration[14].name = auth_tcp
libvirtd__original_configuration[14].comment = Change the authentication scheme for TCP sockets.

If you don't enable SASL, then all TCP traffic is cleartext.
Don't do this outside of a dev/test scenario. For real world
use, always enable SASL and use the GSSAPI or DIGEST-MD5
mechanism in /etc/sasl2/libvirt.conf

libvirtd__original_configuration[14].value = sasl
libvirtd__original_configuration[14].section = authn
libvirtd__original_configuration[14].state = comment
libvirtd__original_configuration[14].weight = 3
libvirtd__original_configuration[15].name = auth_tls
libvirtd__original_configuration[15].comment = Change the authentication scheme for TLS sockets.

TLS sockets already have encryption provided by the TLS
layer, and limited authentication is done by certificates

It is possible to make use of any SASL authentication
mechanism as well, by using 'sasl' for this option

libvirtd__original_configuration[15].value = none
libvirtd__original_configuration[15].section = authn
libvirtd__original_configuration[15].state = comment
libvirtd__original_configuration[15].weight = 4
libvirtd__original_configuration[16].name = access_drivers
libvirtd__original_configuration[16].comment = Change the API access control scheme

By default an authenticated user is allowed access
to all APIs. Access drivers can place restrictions
on this. By default the 'nop' driver is enabled,
meaning no access control checks are done once a
client has authenticated with libvirtd

libvirtd__original_configuration[16].value[0] = polkit
libvirtd__original_configuration[16].section = authn
libvirtd__original_configuration[16].state = comment
libvirtd__original_configuration[16].weight = 5
libvirtd__original_configuration[17].name = key_file
libvirtd__original_configuration[17].comment = Override the default server key file path

libvirtd__original_configuration[17].value = /etc/pki/libvirt/private/serverkey.pem
libvirtd__original_configuration[17].section = tls-cert
libvirtd__original_configuration[17].state = comment
libvirtd__original_configuration[17].weight = 1
libvirtd__original_configuration[18].name = cert_file
libvirtd__original_configuration[18].comment = Override the default server certificate file path

libvirtd__original_configuration[18].value = /etc/pki/libvirt/servercert.pem
libvirtd__original_configuration[18].section = tls-cert
libvirtd__original_configuration[18].state = comment
libvirtd__original_configuration[18].weight = 2
libvirtd__original_configuration[19].name = ca_file
libvirtd__original_configuration[19].comment = Override the default CA certificate path

libvirtd__original_configuration[19].value = /etc/pki/CA/cacert.pem
libvirtd__original_configuration[19].section = tls-cert
libvirtd__original_configuration[19].state = comment
libvirtd__original_configuration[19].weight = 3
libvirtd__original_configuration[20].name = crl_file
libvirtd__original_configuration[20].comment = Specify a certificate revocation list.
Defaults to not using a CRL, uncomment to enable it

libvirtd__original_configuration[20].value = /etc/pki/CA/crl.pem
libvirtd__original_configuration[20].section = tls-cert
libvirtd__original_configuration[20].state = comment
libvirtd__original_configuration[20].weight = 4
libvirtd__original_configuration[21].name = tls_no_sanity_certificate
libvirtd__original_configuration[21].comment = Flag to disable verification of our own server certificates

When libvirtd starts it performs some sanity checks against
its own certificates.

Default is to always run sanity checks. Uncommenting this
will disable sanity checks which is not a good idea

libvirtd__original_configuration[21].value = True
libvirtd__original_configuration[21].section = authz
libvirtd__original_configuration[21].state = comment
libvirtd__original_configuration[21].weight = 1
libvirtd__original_configuration[22].name = tls_no_verify_certificate
libvirtd__original_configuration[22].comment = Flag to disable verification of client certificates

Client certificate verification is the primary authentication mechanism.
Any client which does not present a certificate signed by the CA
will be rejected.

Default is to always verify. Uncommenting this will disable
verification - make sure an IP whitelist is set

libvirtd__original_configuration[22].value = True
libvirtd__original_configuration[22].section = authz
libvirtd__original_configuration[22].state = comment
libvirtd__original_configuration[22].weight = 2
libvirtd__original_configuration[23].name = tls_allowed_dn_list
libvirtd__original_configuration[23].comment = A whitelist of allowed x509 Distinguished Names
This list may contain wildcards such as

  "C=GB,ST=London,L=London,O=Red Hat,CN=*"

See the POSIX fnmatch function for the format of the wildcards.

NB If this is an empty list, no client can connect, so comment out
entirely rather than using empty list to disable these checks

By default, no DNs are checked

libvirtd__original_configuration[23].value[0] = DN1
libvirtd__original_configuration[23].value[1] = DN2
libvirtd__original_configuration[23].section = authz
libvirtd__original_configuration[23].state = comment
libvirtd__original_configuration[23].weight = 3
libvirtd__original_configuration[24].name = sasl_allowed_username_list
libvirtd__original_configuration[24].comment = A whitelist of allowed SASL usernames. The format for username
depends on the SASL authentication mechanism. Kerberos usernames
look like username@REALM

This list may contain wildcards such as

  "*@EXAMPLE.COM"

See the POSIX fnmatch function for the format of the wildcards.

NB If this is an empty list, no client can connect, so comment out
entirely rather than using empty list to disable these checks

By default, no Usernames are checked

libvirtd__original_configuration[24].value[0] = joe@EXAMPLE.COM
libvirtd__original_configuration[24].value[1] = fred@EXAMPLE.COM
libvirtd__original_configuration[24].section = authz
libvirtd__original_configuration[24].state = comment
libvirtd__original_configuration[24].weight = 4
libvirtd__original_configuration[25].name = tls_priority
libvirtd__original_configuration[25].comment = Override the compile time default TLS priority string. The
default is usually "NORMAL" unless overridden at build time.
Only set this is it is desired for libvirt to deviate from
the global default settings.

libvirtd__original_configuration[25].value = NORMAL
libvirtd__original_configuration[25].section = authz
libvirtd__original_configuration[25].state = comment
libvirtd__original_configuration[25].weight = 5
libvirtd__original_configuration[26].name = max_clients
libvirtd__original_configuration[26].comment = The maximum number of concurrent client connections to allow
over all sockets combined.

libvirtd__original_configuration[26].value = 5000
libvirtd__original_configuration[26].section = proc
libvirtd__original_configuration[26].state = comment
libvirtd__original_configuration[26].weight = 1
libvirtd__original_configuration[27].name = max_queued_clients
libvirtd__original_configuration[27].comment = The maximum length of queue of connections waiting to be
accepted by the daemon. Note, that some protocols supporting
retransmission may obey this so that a later reattempt at
connection succeeds.

libvirtd__original_configuration[27].value = 1000
libvirtd__original_configuration[27].section = proc
libvirtd__original_configuration[27].state = comment
libvirtd__original_configuration[27].weight = 2
libvirtd__original_configuration[28].name = max_anonymous_clients
libvirtd__original_configuration[28].comment = The maximum length of queue of accepted but not yet
authenticated clients. The default value is 20. Set this to
zero to turn this feature off.

libvirtd__original_configuration[28].value = 20
libvirtd__original_configuration[28].section = proc
libvirtd__original_configuration[28].state = comment
libvirtd__original_configuration[28].weight = 3
libvirtd__original_configuration[29].name = min_workers
libvirtd__original_configuration[29].comment = The minimum limit sets the number of workers to start up
initially. If the number of active clients exceeds this,
then more threads are spawned, up to max_workers limit.
Typically you would want max_workers to equal maximum
number of clients allowed.

libvirtd__original_configuration[29].value = 5
libvirtd__original_configuration[29].section = proc
libvirtd__original_configuration[29].state = comment
libvirtd__original_configuration[29].weight = 4
libvirtd__original_configuration[30].name = max_workers
libvirtd__original_configuration[30].value = 20
libvirtd__original_configuration[30].section = proc
libvirtd__original_configuration[30].state = comment
libvirtd__original_configuration[30].weight = 5
libvirtd__original_configuration[31].name = prio_workers
libvirtd__original_configuration[31].comment = The number of priority workers. If all workers from above
pool are stuck, some calls marked as high priority
(notably domainDestroy) can be executed in this pool.

libvirtd__original_configuration[31].value = 5
libvirtd__original_configuration[31].section = proc
libvirtd__original_configuration[31].state = comment
libvirtd__original_configuration[31].weight = 6
libvirtd__original_configuration[32].name = max_requests
libvirtd__original_configuration[32].comment = Total global limit on concurrent RPC calls. Should be
at least as large as max_workers. Beyond this, RPC requests
will be read into memory and queued. This directly impacts
memory usage, currently each request requires 256 KB of
memory. So by default up to 5 MB of memory is used

XXX this is not actually enforced yet, only the per-client
limit is used so far

libvirtd__original_configuration[32].value = 20
libvirtd__original_configuration[32].section = proc
libvirtd__original_configuration[32].state = comment
libvirtd__original_configuration[32].weight = 7
libvirtd__original_configuration[33].name = max_client_requests
libvirtd__original_configuration[33].comment = Limit on concurrent requests from a single client
connection. To avoid one client monopolizing the server
this should be a small fraction of the global max_requests
and max_workers parameter

libvirtd__original_configuration[33].value = 5
libvirtd__original_configuration[33].section = proc
libvirtd__original_configuration[33].state = comment
libvirtd__original_configuration[33].weight = 8
libvirtd__original_configuration[34].name = admin_min_workers
libvirtd__original_configuration[34].comment = Same processing controls, but this time for the admin interface.
For description of each option, be so kind to scroll few lines
upwards.

libvirtd__original_configuration[34].value = 1
libvirtd__original_configuration[34].section = proc
libvirtd__original_configuration[34].state = comment
libvirtd__original_configuration[34].weight = 9
libvirtd__original_configuration[35].name = admin_max_workers
libvirtd__original_configuration[35].value = 5
libvirtd__original_configuration[35].section = proc
libvirtd__original_configuration[35].state = comment
libvirtd__original_configuration[35].weight = 10
libvirtd__original_configuration[36].name = admin_max_clients
libvirtd__original_configuration[36].value = 5
libvirtd__original_configuration[36].section = proc
libvirtd__original_configuration[36].state = comment
libvirtd__original_configuration[36].weight = 11
libvirtd__original_configuration[37].name = admin_max_queued_clients
libvirtd__original_configuration[37].value = 5
libvirtd__original_configuration[37].section = proc
libvirtd__original_configuration[37].state = comment
libvirtd__original_configuration[37].weight = 12
libvirtd__original_configuration[38].name = admin_max_client_requests
libvirtd__original_configuration[38].value = 5
libvirtd__original_configuration[38].section = proc
libvirtd__original_configuration[38].state = comment
libvirtd__original_configuration[38].weight = 13
libvirtd__original_configuration[39].name = log_level
libvirtd__original_configuration[39].comment = Logging level: 4 errors, 3 warnings, 2 information, 1 debug
basically 1 will log everything possible
Note: Journald may employ rate limiting of the messages logged
and thus lock up the libvirt daemon. To use the debug level with
journald you have to specify it explicitly in 'log_outputs', otherwise
only information level messages will be logged.

libvirtd__original_configuration[39].value = 3
libvirtd__original_configuration[39].section = log
libvirtd__original_configuration[39].state = comment
libvirtd__original_configuration[39].weight = 1
libvirtd__original_configuration[40].name = log_filters
libvirtd__original_configuration[40].comment = Logging filters:
A filter allows to select a different logging level for a given category
of logs
The format for a filter is one of:
  x:name
  x:+name

    where name is a string which is matched against the category
    given in the VIR_LOG_INIT() at the top of each libvirt source
    file, e. g., "remote", "qemu", or "util.json" (the name in the
    filter can be a substring of the full category name, in order
    to match multiple similar categories), the optional "+" prefix
    tells libvirt to log stack trace for each message matching
    name, and x is the minimal level where matching messages should
    be logged:

  1: DEBUG
  2: INFO
  3: WARNING
  4: ERROR

Multiple filters can be defined in a single @filters, they just need to be
separated by spaces.

e. g. to only get warning or errors from the remote layer and only errors
from the event layer:

libvirtd__original_configuration[40].value = 3:remote 4:event
libvirtd__original_configuration[40].section = log
libvirtd__original_configuration[40].state = comment
libvirtd__original_configuration[40].weight = 2
libvirtd__original_configuration[41].name = log_outputs
libvirtd__original_configuration[41].comment = Logging outputs:
An output is one of the places to save logging information
The format for an output can be:
  x:stderr
    output goes to stderr
  x:syslog:name
    use syslog for the output and use the given name as the ident
  x:file:file_path
    output to a file, with the given filepath
  x:journald
    output to journald logging system
In all case the x prefix is the minimal level, acting as a filter
  1: DEBUG
  2: INFO
  3: WARNING
  4: ERROR

Multiple outputs can be defined, they just need to be separated by spaces.
e. g. to log all warnings and errors to syslog under the libvirtd ident:

libvirtd__original_configuration[41].value = 3:syslog:libvirtd
libvirtd__original_configuration[41].section = log
libvirtd__original_configuration[41].state = comment
libvirtd__original_configuration[41].weight = 3
libvirtd__original_configuration[42].name = log_buffer_size
libvirtd__original_configuration[42].comment = Log debug buffer size:

This configuration option is no longer used, since the global
log buffer functionality has been removed. Please configure
suitable log_outputs/log_filters settings to obtain logs.

libvirtd__original_configuration[42].value = 64
libvirtd__original_configuration[42].section = log
libvirtd__original_configuration[42].state = comment
libvirtd__original_configuration[42].weight = 4
libvirtd__original_configuration[43].name = audit_level
libvirtd__original_configuration[43].comment = This setting allows usage of the auditing subsystem to be altered:

  audit_level == 0  -> disable all auditing
  audit_level == 1  -> enable auditing, only if enabled on host (default)
  audit_level == 2  -> enable auditing, and exit if disabled on host

libvirtd__original_configuration[43].value = 2
libvirtd__original_configuration[43].section = audit
libvirtd__original_configuration[43].state = comment
libvirtd__original_configuration[43].weight = 1
libvirtd__original_configuration[44].name = audit_logging
libvirtd__original_configuration[44].comment = If set to 1, then audit messages will also be sent
via libvirt logging infrastructure. Defaults to 0

libvirtd__original_configuration[44].value = True
libvirtd__original_configuration[44].section = audit
libvirtd__original_configuration[44].state = comment
libvirtd__original_configuration[44].weight = 2
libvirtd__original_configuration[45].name = host_uuid
libvirtd__original_configuration[45].comment = Host UUID is read from one of the sources specified in host_uuid_source.

- 'smbios': fetch the UUID from 'dmidecode -s system-uuid'
- 'machine-id': fetch the UUID from /etc/machine-id

The host_uuid_source default is 'smbios'. If 'dmidecode' does not provide
a valid UUID a temporary UUID will be generated.

Another option is to specify host UUID in host_uuid.

Keep the format of the example UUID below. UUID must not have all digits
be the same.

NB This default all-zeros UUID will not work. Replace
it with the output of the 'uuidgen' command and then
uncomment this entry

libvirtd__original_configuration[45].value = 00000000-0000-0000-0000-000000000000
libvirtd__original_configuration[45].section = uuid
libvirtd__original_configuration[45].state = comment
libvirtd__original_configuration[45].weight = 1
libvirtd__original_configuration[46].name = host_uuid_source
libvirtd__original_configuration[46].value = smbios
libvirtd__original_configuration[46].section = uuid
libvirtd__original_configuration[46].state = comment
libvirtd__original_configuration[46].weight = 2
libvirtd__original_configuration[47].name = keepalive_interval
libvirtd__original_configuration[47].comment = This allows libvirtd to detect broken client connections or even
dead clients.  A keepalive message is sent to a client after
keepalive_interval seconds of inactivity to check if the client is
still responding; keepalive_count is a maximum number of keepalive
messages that are allowed to be sent to the client without getting
any response before the connection is considered broken.  In other
words, the connection is automatically closed approximately after
keepalive_interval * (keepalive_count + 1) seconds since the last
message received from the client.  If keepalive_interval is set to
-1, libvirtd will never send keepalive requests; however clients
can still send them and the daemon will send responses.  When
keepalive_count is set to 0, connections will be automatically
closed after keepalive_interval seconds of inactivity without
sending any keepalive messages.

libvirtd__original_configuration[47].value = 5
libvirtd__original_configuration[47].section = keepalive
libvirtd__original_configuration[47].state = comment
libvirtd__original_configuration[47].weight = 1
libvirtd__original_configuration[48].name = keepalive_count
libvirtd__original_configuration[48].value = 5
libvirtd__original_configuration[48].section = keepalive
libvirtd__original_configuration[48].state = comment
libvirtd__original_configuration[48].weight = 2
libvirtd__original_configuration[49].name = keepalive_required
libvirtd__original_configuration[49].comment = These configuration options are no longer used.  There is no way to
restrict such clients from connecting since they first need to
connect in order to ask for keepalive.

libvirtd__original_configuration[49].value = True
libvirtd__original_configuration[49].section = keepalive
libvirtd__original_configuration[49].state = comment
libvirtd__original_configuration[49].weight = 3
libvirtd__original_configuration[50].name = admin_keepalive_required
libvirtd__original_configuration[50].value = True
libvirtd__original_configuration[50].section = keepalive
libvirtd__original_configuration[50].state = comment
libvirtd__original_configuration[50].weight = 4
libvirtd__original_configuration[51].name = admin_keepalive_interval
libvirtd__original_configuration[51].comment = Keepalive settings for the admin interface

libvirtd__original_configuration[51].value = 5
libvirtd__original_configuration[51].section = keepalive
libvirtd__original_configuration[51].state = comment
libvirtd__original_configuration[51].weight = 5
libvirtd__original_configuration[52].name = admin_keepalive_count
libvirtd__original_configuration[52].value = 5
libvirtd__original_configuration[52].section = keepalive
libvirtd__original_configuration[52].state = comment
libvirtd__original_configuration[52].weight = 6
libvirtd__default_configuration[0].unix_sock_group = {{ libvirtd__unix_sock_group }}
libvirtd__default_configuration[0].unix_sock_ro_perms = 0770
libvirtd__default_configuration[0].unix_sock_rw_perms = 0770
libvirtd__default_configuration[1].name = auth_unix_ro
libvirtd__default_configuration[1].value = none
libvirtd__default_configuration[1].state = {{ "present"
               if (libvirtd__deployment_mode == "opennebula")
               else "ignore" }}
libvirtd__default_configuration[2].name = auth_unix_rw
libvirtd__default_configuration[2].value = none
libvirtd__default_configuration[2].state = {{ "present"
               if (libvirtd__deployment_mode == "opennebula")
               else "ignore" }}
libvirtd__combined_configuration = {{ libvirtd__original_configuration
                                      + libvirtd__default_configuration
                                      + libvirtd__configuration
                                      + libvirtd__group_configuration
                                      + libvirtd__host_configuration }}
libvirtd__configuration_sections[0].name = network
libvirtd__configuration_sections[0].title = Network connectivity controls
libvirtd__configuration_sections[1].name = unix-socket
libvirtd__configuration_sections[1].title = UNIX socket access controls
libvirtd__configuration_sections[2].name = authn
libvirtd__configuration_sections[2].title = Authentication
libvirtd__configuration_sections[2].comment = - none: do not perform auth checks. If you can connect to the
        socket you are allowed. This is suitable if there are
        restrictions on connecting to the socket (eg, UNIX
        socket permissions), or if there is a lower layer in
        the network providing auth (eg, TLS/x509 certificates)

- sasl: use SASL infrastructure. The actual auth scheme is then
        controlled from /etc/sasl2/libvirt.conf. For the TCP
        socket only GSSAPI & DIGEST-MD5 mechanisms will be used.
        For non-TCP or TLS sockets, any scheme is allowed.

- polkit: use PolicyKit to authenticate. This is only suitable
          for use on the UNIX sockets. The default policy will
          require a user to supply their own password to gain
          full read/write access (aka sudo like), while anyone
          is allowed read/only access.

libvirtd__configuration_sections[3].name = tls-cert
libvirtd__configuration_sections[3].title = TLS X.509 certificate configuration
libvirtd__configuration_sections[4].name = authz
libvirtd__configuration_sections[4].title = Authorization controls
libvirtd__configuration_sections[5].name = proc
libvirtd__configuration_sections[5].title = Processing controls
libvirtd__configuration_sections[6].name = log
libvirtd__configuration_sections[6].title = Logging controls
libvirtd__configuration_sections[7].name = audit
libvirtd__configuration_sections[7].title = Auditing controls
libvirtd__configuration_sections[8].name = uuid
libvirtd__configuration_sections[8].title = UUID of the host
libvirtd__configuration_sections[9].name = keepalive
libvirtd__configuration_sections[9].title = Keepalive protocol
libvirtd__configuration_sections[10].name = unknown
libvirtd__configuration_sections[10].title = Other parameters
libvirtd__ksm_enabled = False
libvirtd__ksm_sleep_milisecs = 20
libvirtd__ksm_pages_to_scan = 100
libvirtd__ferm_post_hook = {{ True
                              if (ansible_local | d() and ansible_local.ferm | d() and
                                  (ansible_local.ferm.enabled | d()) | bool)
                              else False }}
libvirtd__ferm__dependent_rules[0].type = custom
libvirtd__ferm__dependent_rules[0].filename = bootpc_checksum
libvirtd__ferm__dependent_rules[0].weight = 30
libvirtd__ferm__dependent_rules[0].rules = # Add checksums to BOOTP packets from virtual machines and containers.
# https://www.redhat.com/archives/libvir-list/2010-August/msg00035.html
@hook post "iptables -A POSTROUTING -t mangle -p udp --dport bootpc -j CHECKSUM --checksum-fill";

libvirtd__ferm__dependent_rules[1].type = custom
libvirtd__ferm__dependent_rules[1].filename = reload_libvirt
libvirtd__ferm__dependent_rules[1].weight = zz
libvirtd__ferm__dependent_rules[1].rules = @hook post "type libvirtd > /dev/null && (systemctl reload libvirtd || true)";
libvirtd__ferm__dependent_rules[1].state = absent
libvirtd__python__dependent_packages3[0] = python3-libvirt
libvirtd__python__dependent_packages2[0] = python-libvirt
libvirtd__nsswitch__dependent_services[0] = libvirt
libvirtd__nsswitch__dependent_services[1] = libvirt_guest
