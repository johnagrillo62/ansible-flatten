~d0.name = Import DebOps global handlers
~d1.ansible.builtin.import_role = 
~d2.name = 'global_handlers'
~d0.name = Install pgBadger APT packages
~d1.ansible.builtin.package = 
~d2.name = '{{ q("flattened", pgbadger__base_packages
~d2.state = 'present'
~d1.register = pgbadger__register_packages
~d1.until = pgbadger__register_packages is succeeded
~d0.name = Create system UNIX group for pgBadger
~d1.ansible.builtin.group = 
~d2.name = '{{ pgbadger__group }}'
~d2.state = 'present'
~d2.system = True
~d0.name = Create system UNIX account for pgBadger
~d1.ansible.builtin.user = 
~d2.name = '{{ pgbadger__user }}'
~d2.group = '{{ pgbadger__group }}'
~d2.groups = '{{ pgbadger__additional_groups }}'
~d2.home = '{{ pgbadger__home }}'
~d2.comment = '{{ pgbadger__comment }}'
~d2.shell = '/bin/bash'
~d2.state = 'present'
~d2.system = True
~d2.generate_ssh_key = True
~d0.name = Create webroot directory for pgBadger
~d1.ansible.builtin.file = 
~d2.path = '{{ item }}'
~d2.state = 'directory'
~d2.owner = '{{ pgbadger__user }}'
~d2.group = '{{ pgbadger__group }}'
~d2.mode = '0755'
~d1.loop = 
~d0.name = Get pgBadger SSH public key from its account
~d1.ansible.builtin.slurp = 
~d2.src = '{{ pgbadger__ssh_public_key_file }}'
~d1.register = pgbadger__register_ssh_public_key
~d1.when = pgbadger__ssh_accounts_enabled | bool
~d1.tags = [ 'role::pgbadger:ssh' ]
~d0.name = Gather facts from remote hosts
~d1.ansible.builtin.setup = 
~d2.gather_subset = '!all'
~d2.fact_path = '/dev/null'
~d1.delegate_to = '{{ item }}'
~d1.delegate_facts = True
~d1.loop = '{{ groups[pgbadger__ssh_inventory_group] }}'
~d1.when = pgbadger__ssh_accounts_enabled | bool and
~d1.tags = [ 'role::pgbadger:ssh' ]
~d0.name = Set up remote SSH access for pgBadger
~d1.ansible.builtin.include_tasks = 
~d2.file = 'ssh_accounts.yml'
~d2.apply = 
~d3.tags = [ 'role::pgbadger:ssh' ]
~d1.loop = '{{ groups[pgbadger__ssh_inventory_group] }}'
~d1.when = pgbadger__ssh_accounts_enabled | bool and
~d1.tags = [ 'role::pgbadger:ssh' ]
~d0.name = Verify that all required parameters are present
~d1.ansible.builtin.assert = 
~d2.that = 
~d2.quiet = True
~d1.loop = '{{ pgbadger__combined_instances | debops.debops.parse_kv_items }}'
~d1.loop_control = 
~d2.label = '{{ {"name": item.name, "state": item.state} }}'
~d0.name = Remove pgBadger instance scripts when requested
~d1.ansible.builtin.file = 
~d2.path = '{{ pgbadger__scripts_path + "/" + item.name }}'
~d2.state = 'absent'
~d1.loop = '{{ pgbadger__combined_instances | debops.debops.parse_kv_items }}'
~d1.loop_control = 
~d2.label = '{{ {"name": item.name, "state": item.state} }}'
~d1.when = (item.state | d('present')) in [ 'absent' ]
~d0.name = Generate pgBadger instance scripts
~d1.ansible.builtin.template = 
~d2.src = 'home/scripts/instance.j2'
~d2.dest = '{{ pgbadger__scripts_path + "/" + item.name }}'
~d2.owner = '{{ pgbadger__user }}'
~d2.group = '{{ pgbadger__group }}'
~d2.mode = '0755'
~d1.loop = '{{ pgbadger__combined_instances | debops.debops.parse_kv_items }}'
~d1.loop_control = 
~d2.label = '{{ {"name": item.name, "state": item.state} }}'
~d1.when = (item.state | d('present')) not in [ 'absent', 'ignore', 'init' ]
~d0.name = Manage pgBadger cron entry
~d1.ansible.builtin.cron = 
~d2.name = 'Execute pgbadger scripts'
~d2.special_time = '{{ pgbadger__cron_interval }}'
~d2.state = '{{ pgbadger__cron_deploy_state }}'
~d2.user = '{{ pgbadger__user }}'
~d2.job = 'run-parts {{ pgbadger__scripts_path }}'
~d0.name = Make sure that Ansible local facts directory exists
~d1.ansible.builtin.file = 
~d2.path = '/etc/ansible/facts.d'
~d2.state = 'directory'
~d2.mode = '0755'
~d0.name = Save pgbadger local facts
~d1.ansible.builtin.template = 
~d2.src = 'etc/ansible/facts.d/pgbadger.fact.j2'
~d2.dest = '/etc/ansible/facts.d/pgbadger.fact'
~d2.mode = '0755'
~d1.notify = [ 'Refresh host facts' ]
~d1.tags = [ 'meta::facts' ]
~d0.name = Update Ansible facts if they were modified
~d1.ansible.builtin.meta = 'flush_handlers'
