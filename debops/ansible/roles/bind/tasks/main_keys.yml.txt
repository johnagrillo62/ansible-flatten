~d0.name = Create sanitised list of keys
~d1.ansible.builtin.set_fact = 
~d2.bind__tmp_keys = '{{ bind__tmp_keys | d([])
~d12.+ [item | combine({"state" = item.state | d("present") | lower,
~d21."type" = item.type | mandatory | upper,
~d21."dir" = item.dir | d("/etc/bind/keys/"),
~d21."owner" = item.owner | d("root"),
~d21."group" = item.group | d("bind"),
~d21."include" = (item.include | d(True) | bool)
~d21."download" = item.download | d(True if item.source | d("host") == "host" else False) | bool,
~d21."source" = item.source | d("host"),
~d21."source_path" = item.source_path | d(""),
~d21."remove_private_key" = item.remove_private_key | d(True) | bool,
~d21."algorithm" = (item.algorithm | mandatory)
~d21."creates" = (item.name + ".key")
~d21."removes" = (item.name + ".key")
~d21."public_key" = (item.name + ".key")
~d21."private_key" = (item.name + ".key")
~d1.when = 
~d1.loop = '{{ bind__combined_keys | d([]) | debops.debops.parse_kv_items(name="name") }}'
~d1.loop_control = 
~d2.label = '{{ item.name | d("unknown") }}'
~d1.tags = [ 'role::bind:config', 'role::bind:keys' ]
~d0.name = Verify key sanity
~d1.ansible.builtin.assert = 
~d2.that = 
~d2.quiet = true
~d1.loop = '{{ bind__tmp_keys | d([]) }}'
~d1.loop_control = 
~d2.label = '{{ item.name }}'
~d1.tags = [ 'role::bind:config', 'role::bind:keys' ]
~d0.name = Create TSIG keys
~d1.ansible.builtin.shell = 
~d2.chdir = '{{ item.dir }}'
~d2.cmd = umask 027;
~d4.chown {{ (item.owner + " = " + item.group) | quote }} {{ item.creates | quote }}
~d2.creates = '{{ item.creates }}'
~d1.when = 
~d1.loop = '{{ bind__tmp_keys | d([]) }}'
~d1.loop_control = 
~d2.label = '{{ item.name }}'
~d1.notify = [ 'Test named configuration and restart' ]
~d1.tags = [ 'role::bind:keys' ]
~d0.name = Fetch TSIG keys
~d1.ansible.builtin.fetch = 
~d2.src = '{{ item.dir + "/" + item.public_key }}'
~d2.dest = '{{ secret + "/bind/" + inventory_hostname + "/" }}'
~d2.flat = True
~d1.when = 
~d1.loop = '{{ bind__tmp_keys | d([]) }}'
~d1.loop_control = 
~d2.label = '{{ item.name }}'
~d1.tags = [ 'role::bind:keys' ]
~d0.name = Create SIG(0) keys
~d1.ansible.builtin.shell = 
~d2.chdir = '{{ item.dir }}'
~d2.cmd = umask 027;
~d4.chown {{ (item.owner + " = " + item.group) | quote }} {{ item.creates }}
~d2.creates = '{{ item.creates }}'
~d1.when = 
~d1.loop = '{{ bind__tmp_keys | d([]) }}'
~d1.loop_control = 
~d2.label = '{{ item.name }}'
~d1.notify = [ 'Test named configuration and restart' ]
~d1.tags = [ 'role::bind:keys' ]
~d0.name = Find SIG(0) keys to fetch
~d1.ansible.builtin.find = 
~d2.paths = '{{ item.dir }}'
~d2.use_regex = False
~d2.recurse = False
~d2.patterns = 
~d1.when = 
~d1.register = bind__tmp_find_sig0_keys
~d1.loop = '{{ bind__tmp_keys | d([]) }}'
~d1.loop_control = 
~d2.label = '{{ item.name }}'
~d1.tags = [ 'role::bind:keys' ]
~d0.name = Build combined list of SIG(0) keys to fetch
~d1.ansible.builtin.set_fact = 
~d2.bind__tmp_sig0_fetch = '{{ bind__tmp_sig0_fetch | d([]) + item.files | map(attribute="path") }}'  # noqa jinja[invalid]
~d1.loop = '{{ bind__tmp_find_sig0_keys.results | d([]) }}'
~d1.when = item.files is defined
~d1.loop_control = 
~d2.label = '{{ item.item.name }}'
~d1.tags = [ 'role::bind:keys' ]
~d0.name = Fetch SIG(0) keys
~d1.ansible.builtin.fetch = 
~d2.src = '{{ item }}'
~d2.dest = '{{ secret + "/bind/" + inventory_hostname + "/" }}'
~d2.flat = True
~d1.loop = '{{ bind__tmp_sig0_fetch | d([]) }}'
~d1.tags = [ 'role::bind:keys' ]
~d0.name = Find SIG(0) private keys to remove
~d1.ansible.builtin.find = 
~d2.paths = '{{ item.dir }}'
~d2.use_regex = False
~d2.recurse = False
~d2.patterns = 
~d1.when = 
~d1.register = bind__tmp_find_sig0_keys
~d1.loop = '{{ bind__tmp_keys | d([]) }}'
~d1.loop_control = 
~d2.label = '{{ item.name }}'
~d1.tags = [ 'role::bind:keys' ]
~d0.name = Build combined list of SIG(0) private keys to remove
~d1.ansible.builtin.set_fact = 
~d2.bind__tmp_sig0_remove = '{{ bind__tmp_sig0_remove | d([]) + item.files | d([]) | map(attribute="path") }}'
~d1.loop = '{{ bind__tmp_find_sig0_keys.results | d([]) }}'
~d1.when = item.files is defined
~d1.loop_control = 
~d2.label = '{{ item.item.name }}'
~d1.tags = [ 'role::bind:keys' ]
~d0.name = Remove SIG(0) private keys
~d1.ansible.builtin.file = 
~d2.path = '{{ item }}'
~d2.state = absent
~d1.loop = '{{ bind__tmp_sig0_remove | d([]) }}'
~d1.tags = [ 'role::bind:keys' ]
~d0.name = Remove TSIG/SIG(0) keys configured as absent
~d1.ansible.builtin.shell = # noqa command-instead-of-shell no-free-form
~d2.chdir = '{{ item.dir }}'
~d2.cmd = rm -f {{ item.removes }}
~d2.removes = '{{ item.removes }}'
~d1.when = 
~d1.loop = '{{ bind__tmp_keys | d([]) }}'
~d1.loop_control = 
~d2.label = '{{ item.name }}'
~d1.notify = [ 'Test named configuration and restart' ]
~d1.tags = [ 'role::bind:keys' ]
~d0.name = Upload TSIG/SIG(0) keys from the controller
~d1.ansible.builtin.copy = 
~d2.src = '{{ item.source_path if item.source_path.startswith("/") else secret + "/" + item.source_path }}'
~d2.dest = '{{ item.dir + "/" + item.source_path | basename }}'
~d2.owner = '{{ item.owner }}'
~d2.group = '{{ item.group }}'
~d2.mode = '0640'
~d1.when = 
~d1.loop = '{{ bind__tmp_keys | d([]) }}'
~d1.loop_control = 
~d2.label = '{{ item.name }}'
~d1.notify = [ 'Test named configuration and restart' ]
~d1.tags = [ 'role::bind:keys' ]
