[0].name = Reset | stop services
[0].service.name = {{ item }}
[0].service.state = stopped
[0].service.enabled = false
[0].with_items[0] = kubelet.service
[0].with_items[1] = cri-dockerd.service
[0].with_items[2] = cri-dockerd.socket
[0].failed_when = false
[0].tags[0] = services
[1].name = Reset | remove services
[1].file.path = /etc/systemd/system/{{ item }}
[1].file.state = absent
[1].with_items[0] = kubelet.service
[1].with_items[1] = cri-dockerd.service
[1].with_items[2] = cri-dockerd.socket
[1].with_items[3] = calico-node.service
[1].with_items[4] = containerd.service.d/http-proxy.conf
[1].with_items[5] = crio.service.d/http-proxy.conf
[1].with_items[6] = k8s-certs-renew.service
[1].with_items[7] = k8s-certs-renew.timer
[1].register = services_removed
[1].tags[0] = services
[1].tags[1] = containerd
[1].tags[2] = crio
[2].name = Reset | Remove Docker
[2].include_role.name = container-engine/docker
[2].include_role.tasks_from = reset
[2].when = container_manager == 'docker'
[2].tags[0] = docker
[3].name = Reset | systemctl daemon-reload
[3].systemd_service.daemon_reload = true
[3].when = services_removed.changed
[4].name = Reset | check if crictl is present
[4].stat.path = {{ bin_dir }}/crictl
[4].stat.get_attributes = false
[4].stat.get_checksum = false
[4].stat.get_mime = false
[4].register = crictl
[5].name = Reset | stop all cri containers
[5].shell = set -o pipefail && {{ bin_dir }}/crictl ps -q | xargs -r {{ bin_dir }}/crictl -t 60s stop -t {{ cri_stop_containers_grace_period }}
[5].args.executable = /bin/bash
[5].register = remove_all_cri_containers
[5].retries = 5
[5].until = remove_all_cri_containers.rc == 0
[5].delay = 5
[5].tags[0] = crio
[5].tags[1] = containerd
[5].when[0] = crictl.stat.exists
[5].when[1] = container_manager in ["crio", "containerd"]
[5].when[2] = ansible_facts.services['containerd.service'] is defined or ansible_facts.services['cri-o.service'] is defined
[5].ignore_errors = true
[6].name = Reset | force remove all cri containers
[6].command = {{ bin_dir }}/crictl rm -a -f
[6].register = remove_all_cri_containers
[6].retries = 5
[6].until = remove_all_cri_containers.rc == 0
[6].delay = 5
[6].tags[0] = crio
[6].tags[1] = containerd
[6].when[0] = crictl.stat.exists
[6].when[1] = container_manager in ["crio", "containerd"]
[6].when[2] = deploy_container_engine
[6].when[3] = ansible_facts.services['containerd.service'] is defined or ansible_facts.services['cri-o.service'] is defined
[6].ignore_errors = true
[7].name = Reset | stop and disable crio service
[7].service.name = crio
[7].service.state = stopped
[7].service.enabled = false
[7].failed_when = false
[7].tags[0] = crio
[7].when = container_manager == "crio"
[8].name = Reset | forcefully wipe CRI-O's container and image storage
[8].command = crio wipe -f
[8].failed_when = false
[8].tags[0] = crio
[8].when = container_manager == "crio"
[9].name = Reset | stop all cri pods
[9].shell = set -o pipefail && {{ bin_dir }}/crictl pods -q | xargs -r {{ bin_dir }}/crictl -t 60s stopp
[9].args.executable = /bin/bash
[9].register = remove_all_cri_containers
[9].retries = 5
[9].until = remove_all_cri_containers.rc == 0
[9].delay = 5
[9].tags[0] = containerd
[9].when[0] = crictl.stat.exists
[9].when[1] = container_manager == "containerd"
[9].when[2] = ansible_facts.services['containerd.service'] is defined or ansible_facts.services['cri-o.service'] is defined
[9].ignore_errors = true
[10].name = Reset | force remove all cri pods
[10].block[0].name = Reset | force remove all cri pods
[10].block[0].command = {{ bin_dir }}/crictl rmp -a -f
[10].block[0].register = remove_all_cri_containers
[10].block[0].retries = 5
[10].block[0].until = remove_all_cri_containers.rc == 0
[10].block[0].delay = 5
[10].block[0].tags[0] = containerd
[10].block[0].when[0] = crictl.stat.exists
[10].block[0].when[1] = container_manager == "containerd"
[10].block[0].when[2] = ansible_facts.services['containerd.service'] is defined or ansible_facts.services['cri-o.service'] is defined
[10].rescue[0].name = Reset | force remove all cri pods (rescue)
[10].rescue[0].shell = ip netns list | cut -d' ' -f 1 | xargs -n1 ip netns delete && {{ bin_dir }}/crictl rmp -a -f
[10].rescue[0].ignore_errors = true
[10].rescue[0].changed_when = true
[11].name = Reset | stop containerd and etcd services
[11].service.name = {{ item }}
[11].service.state = stopped
[11].service.enabled = false
[11].with_items[0] = containerd.service
[11].with_items[1] = etcd.service
[11].with_items[2] = etcd-events.service
[11].failed_when = false
[11].tags[0] = services
[12].name = Reset | remove containerd and etcd services
[12].file.path = /etc/systemd/system/{{ item }}
[12].file.state = absent
[12].with_items[0] = containerd.service
[12].with_items[1] = etcd.service
[12].with_items[2] = etcd-events.service
[12].register = services_removed_secondary
[12].tags[0] = services
[12].tags[1] = containerd
[13].name = Reset | systemctl daemon-reload
[13].systemd_service.daemon_reload = true
[13].when = services_removed_secondary.changed
[14].name = Reset | gather mounted kubelet dirs
[14].shell = set -o pipefail && mount | grep /var/lib/kubelet/ | awk '{print $3}' | tac
[14].args.executable = /bin/bash
[14].check_mode = false
[14].register = mounted_dirs
[14].failed_when = false
[14].changed_when = false
[14].tags[0] = mounts
[15].name = Reset | unmount kubelet dirs
[15].command = umount -f {{ item }}
[15].with_items = {{ mounted_dirs.stdout_lines }}
[15].register = umount_dir
[15].when = mounted_dirs
[15].retries = 4
[15].until = umount_dir.rc == 0
[15].delay = 5
[15].tags[0] = mounts
[16].name = Set IPv4 iptables default policies to ACCEPT
[16].iptables.chain = {{ item }}
[16].iptables.policy = ACCEPT
[16].with_items[0] = INPUT
[16].with_items[1] = FORWARD
[16].with_items[2] = OUTPUT
[16].when = flush_iptables | bool and ipv4_stack
[16].tags[0] = iptables
[17].name = Flush iptables
[17].iptables.table = {{ item }}
[17].iptables.flush = true
[17].with_items[0] = filter
[17].with_items[1] = nat
[17].with_items[2] = mangle
[17].with_items[3] = raw
[17].when = flush_iptables | bool and ipv4_stack
[17].tags[0] = iptables
[18].name = Delete IPv4 user-defined chains
[18].command = iptables -X
[18].when = flush_iptables | bool and ipv4_stack
[18].tags[0] = iptables
[19].name = Set IPv6 ip6tables default policies to ACCEPT
[19].iptables.chain = {{ item }}
[19].iptables.policy = ACCEPT
[19].iptables.ip_version = ipv6
[19].with_items[0] = INPUT
[19].with_items[1] = FORWARD
[19].with_items[2] = OUTPUT
[19].when = flush_iptables | bool and ipv6_stack
[19].tags[0] = ip6tables
[20].name = Flush ip6tables
[20].iptables.table = {{ item }}
[20].iptables.flush = true
[20].iptables.ip_version = ipv6
[20].with_items[0] = filter
[20].with_items[1] = nat
[20].with_items[2] = mangle
[20].with_items[3] = raw
[20].when = flush_iptables | bool and ipv6_stack
[20].tags[0] = ip6tables
[21].name = Delete IPv6 user-defined chains
[21].command = ip6tables -X
[21].when = flush_iptables | bool and ipv6_stack
[21].tags[0] = ip6tables
[22].name = Clear IPVS virtual server table
[22].command = ipvsadm -C
[22].ignore_errors = true
[22].when[0] = kube_proxy_mode == 'ipvs' and 'k8s_cluster' in group_names
[23].name = Reset | check kube-ipvs0 network device
[23].stat.path = /sys/class/net/kube-ipvs0
[23].stat.get_attributes = false
[23].stat.get_checksum = false
[23].stat.get_mime = false
[23].register = kube_ipvs0
[24].name = Reset | Remove kube-ipvs0
[24].command = ip link del kube-ipvs0
[24].when[0] = kube_proxy_mode == 'ipvs'
[24].when[1] = kube_ipvs0.stat.exists
[25].name = Reset | check nodelocaldns network device
[25].stat.path = /sys/class/net/nodelocaldns
[25].stat.get_attributes = false
[25].stat.get_checksum = false
[25].stat.get_mime = false
[25].register = nodelocaldns_device
[26].name = Reset | Remove nodelocaldns
[26].command = ip link del nodelocaldns
[26].when[0] = enable_nodelocaldns | default(false) | bool
[26].when[1] = nodelocaldns_device.stat.exists
[27].name = Reset | Check whether /var/lib/kubelet directory exists
[27].stat.path = /var/lib/kubelet
[27].stat.get_attributes = false
[27].stat.get_checksum = false
[27].stat.get_mime = false
[27].register = var_lib_kubelet_directory
[28].name = Reset | Find files/dirs with immutable flag in /var/lib/kubelet
[28].command = lsattr -laR /var/lib/kubelet/
[28].become = true
[28].register = var_lib_kubelet_files_dirs_w_attrs
[28].changed_when = false
[28].no_log = true
[28].when = var_lib_kubelet_directory.stat.exists
[29].name = Reset | Remove immutable flag from files/dirs in /var/lib/kubelet
[29].file.path = {{ filedir_path }}
[29].file.state = touch
[29].file.attributes = -i
[29].file.mode = 0644
[29].loop = {{ var_lib_kubelet_files_dirs_w_attrs.stdout_lines | select('search', 'Immutable') | list }}
[29].loop_control.loop_var = file_dir_line
[29].loop_control.label = {{ filedir_path }}
[29].vars.filedir_path = {{ file_dir_line.split(' ')[0] }}
[29].when = var_lib_kubelet_directory.stat.exists
[30].name = Reset | delete some files and directories
[30].file.path = {{ item }}
[30].file.state = absent
[30].with_items[0] = {{ kube_config_dir }}
[30].with_items[1] = /var/lib/kubelet
[30].with_items[2] = {{ containerd_storage_dir }}
[30].with_items[3] = {{ ansible_env.HOME | default('/root') }}/.kube
[30].with_items[4] = {{ ansible_env.HOME | default('/root') }}/.helm
[30].with_items[5] = {{ ansible_env.HOME | default('/root') }}/.config/helm
[30].with_items[6] = {{ ansible_env.HOME | default('/root') }}/.cache/helm
[30].with_items[7] = {{ ansible_env.HOME | default('/root') }}/.local/share/helm
[30].with_items[8] = {{ etcd_data_dir }}
[30].with_items[9] = {{ etcd_events_data_dir }}
[30].with_items[10] = {{ etcd_config_dir }}
[30].with_items[11] = /var/log/calico
[30].with_items[12] = /var/log/openvswitch
[30].with_items[13] = /var/log/ovn
[30].with_items[14] = /var/log/kube-ovn
[30].with_items[15] = /var/log/containers
[30].with_items[16] = /etc/cni
[30].with_items[17] = /etc/nerdctl
[30].with_items[18] = {{ nginx_config_dir }}
[30].with_items[19] = /etc/systemd/resolved.conf.d/kubespray.conf
[30].with_items[20] = /etc/etcd.env
[30].with_items[21] = /etc/calico
[30].with_items[22] = /etc/NetworkManager/conf.d/calico.conf
[30].with_items[23] = /etc/NetworkManager/conf.d/dns.conf
[30].with_items[24] = /etc/NetworkManager/conf.d/k8s.conf
[30].with_items[25] = /opt/cni
[30].with_items[26] = /etc/dhcp/dhclient.d/zdnsupdate.sh
[30].with_items[27] = /etc/dhcp/dhclient-exit-hooks.d/zdnsupdate
[30].with_items[28] = /run/flannel
[30].with_items[29] = /etc/flannel
[30].with_items[30] = /run/kubernetes
[30].with_items[31] = /usr/local/share/ca-certificates/etcd-ca.crt
[30].with_items[32] = /usr/local/share/ca-certificates/kube-ca.crt
[30].with_items[33] = /etc/ssl/certs/etcd-ca.pem
[30].with_items[34] = /etc/ssl/certs/kube-ca.pem
[30].with_items[35] = /etc/pki/ca-trust/source/anchors/etcd-ca.crt
[30].with_items[36] = /etc/pki/ca-trust/source/anchors/kube-ca.crt
[30].with_items[37] = /var/log/pods/
[30].with_items[38] = {{ bin_dir }}/kubelet
[30].with_items[39] = {{ bin_dir }}/cri-dockerd
[30].with_items[40] = {{ bin_dir }}/etcd-scripts
[30].with_items[41] = {{ bin_dir }}/etcd
[30].with_items[42] = {{ bin_dir }}/etcd-events
[30].with_items[43] = {{ bin_dir }}/etcdctl
[30].with_items[44] = {{ bin_dir }}/etcdctl.sh
[30].with_items[45] = {{ bin_dir }}/kubernetes-scripts
[30].with_items[46] = {{ bin_dir }}/kubectl
[30].with_items[47] = {{ bin_dir }}/kubeadm
[30].with_items[48] = {{ bin_dir }}/helm
[30].with_items[49] = {{ bin_dir }}/calicoctl
[30].with_items[50] = {{ bin_dir }}/calicoctl.sh
[30].with_items[51] = {{ bin_dir }}/calico-upgrade
[30].with_items[52] = {{ bin_dir }}/crictl
[30].with_items[53] = {{ bin_dir }}/nerdctl
[30].with_items[54] = {{ bin_dir }}/netctl
[30].with_items[55] = {{ bin_dir }}/k8s-certs-renew.sh
[30].with_items[56] = /var/lib/cni
[30].with_items[57] = /etc/openvswitch
[30].with_items[58] = /run/openvswitch
[30].with_items[59] = /var/lib/kube-router
[30].with_items[60] = /var/lib/calico
[30].with_items[61] = /etc/cilium
[30].with_items[62] = /run/calico
[30].with_items[63] = /etc/bash_completion.d/kubectl.sh
[30].with_items[64] = /etc/bash_completion.d/crictl
[30].with_items[65] = /etc/bash_completion.d/nerdctl
[30].with_items[66] = /etc/modules-load.d/kube_proxy-ipvs.conf
[30].with_items[67] = /etc/modules-load.d/kubespray-br_netfilter.conf
[30].with_items[68] = /etc/modules-load.d/kubespray-kata-containers.conf
[30].with_items[69] = /usr/libexec/kubernetes
[30].with_items[70] = /etc/origin/openvswitch
[30].with_items[71] = /etc/origin/ovn
[30].with_items[72] = {{ sysctl_file_path }}
[30].with_items[73] = /etc/crictl.yaml
[30].ignore_errors = true
[30].tags[0] = files
[31].name = Reset | remove containerd binary files
[31].file.path = {{ containerd_bin_dir }}/{{ item }}
[31].file.state = absent
[31].with_items[0] = containerd
[31].with_items[1] = containerd-shim
[31].with_items[2] = containerd-shim-runc-v1
[31].with_items[3] = containerd-shim-runc-v2
[31].with_items[4] = containerd-stress
[31].with_items[5] = crictl
[31].with_items[6] = critest
[31].with_items[7] = ctd-decoder
[31].with_items[8] = ctr
[31].with_items[9] = runc
[31].ignore_errors = true
[31].when = container_manager == 'containerd'
[31].tags[0] = files
[32].name = Reset | remove dns settings from dhclient.conf
[32].blockinfile.path = {{ item }}
[32].blockinfile.state = absent
[32].blockinfile.marker = # Ansible entries {mark}
[32].failed_when = false
[32].with_items[0] = /etc/dhclient.conf
[32].with_items[1] = /etc/dhcp/dhclient.conf
[32].tags[0] = files
[32].tags[1] = dns
[33].name = Reset | include file with reset tasks specific to the network_plugin if exists
[33].include_role.name = network_plugin/{{ kube_network_plugin }}
[33].include_role.tasks_from = reset
[33].when[0] = kube_network_plugin in ['flannel', 'cilium', 'kube-router', 'calico']
[33].tags[0] = network
[34].name = Reset | Restart network
[34].when[0] = ansible_os_family not in ["Flatcar", "Flatcar Container Linux by Kinvolk"]
[34].when[1] = reset_restart_network | bool
[34].tags[0] = services
[34].tags[1] = network
[34].block[0].name = Gather active network services
[34].block[0].systemd.name = {{ item }}
[34].block[0].loop[0] = NetworkManager
[34].block[0].loop[1] = systemd-networkd
[34].block[0].loop[2] = networking
[34].block[0].loop[3] = network
[34].block[0].register = service_status
[34].block[0].changed_when = false
[34].block[0].ignore_errors = true
[34].block[1].name = Restart active network services
[34].block[1].systemd.name = {{ item }}
[34].block[1].systemd.state = restarted
[34].block[1].loop = {{ service_status.results | selectattr('status.ActiveState', '==', 'active') | map(attribute='item') }}
