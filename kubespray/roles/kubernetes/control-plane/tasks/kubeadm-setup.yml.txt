[0].name = Install OIDC certificate
[0].copy.content = {{ kube_oidc_ca_cert | b64decode }}
[0].copy.dest = {{ kube_oidc_ca_file }}
[0].copy.owner = root
[0].copy.group = root
[0].copy.mode = 0644
[0].when[0] = kube_oidc_auth
[0].when[1] = kube_oidc_ca_cert is defined
[1].name = Kubeadm | Check if kubeadm has already run
[1].stat.path = /var/lib/kubelet/config.yaml
[1].stat.get_attributes = false
[1].stat.get_checksum = false
[1].stat.get_mime = false
[1].register = kubeadm_already_run
[2].name = Kubeadm | Backup kubeadm certs / kubeconfig
[2].import_tasks = kubeadm-backup.yml
[2].when[0] = kubeadm_already_run.stat.exists
[3].name = Kubeadm | aggregate all SANs
[3].set_fact.apiserver_sans = {{ _apiserver_sans | flatten | select | unique }}
[3].vars._apiserver_sans[0] = kubernetes
[3].vars._apiserver_sans[1] = kubernetes.default
[3].vars._apiserver_sans[2] = kubernetes.default.svc
[3].vars._apiserver_sans[3] = kubernetes.default.svc.{{ dns_domain }}
[3].vars._apiserver_sans[4] = {{ kube_apiserver_ip }}
[3].vars._apiserver_sans[5] = localhost
[3].vars._apiserver_sans[6] = 127.0.0.1
[3].vars._apiserver_sans[7] = ::1
[3].vars._apiserver_sans[8] = {{ apiserver_loadbalancer_domain_name | d('') }}
[3].vars._apiserver_sans[9] = {{ loadbalancer_apiserver.address | d('') }}
[3].vars._apiserver_sans[10] = {{ supplementary_addresses_in_ssl_keys }}
[3].vars._apiserver_sans[11] = {{ groups['kube_control_plane'] | map('extract', hostvars, 'main_access_ip') }}
[3].vars._apiserver_sans[12] = {{ groups['kube_control_plane'] | map('extract', hostvars, 'main_ip') }}
[3].vars._apiserver_sans[13] = {{ groups['kube_control_plane'] | map('extract', hostvars, ['ansible_default_ipv4', 'address']) | select('defined') }}
[3].vars._apiserver_sans[14] = {{ groups['kube_control_plane'] | map('extract', hostvars, ['ansible_default_ipv6', 'address']) | select('defined') }}
[3].vars._apiserver_sans[15] = {{ groups['kube_control_plane'] | map('extract', hostvars, 'ansible_hostname') }}
[3].vars._apiserver_sans[16] = {{ groups['kube_control_plane'] | map('extract', hostvars, 'ansible_fqdn') }}
[3].vars._apiserver_sans[17] = {{ kube_override_hostname }}
[3].vars._apiserver_sans[18] = {{ kube_vip_address }}
[3].tags = facts
[4].name = Create audit-policy directory
[4].file.path = {{ audit_policy_file | dirname }}
[4].file.state = directory
[4].file.mode = 0640
[4].when = kubernetes_audit or kubernetes_audit_webhook
[5].name = Write api audit policy yaml
[5].template.src = apiserver-audit-policy.yaml.j2
[5].template.dest = {{ audit_policy_file }}
[5].template.mode = 0640
[5].when = kubernetes_audit or kubernetes_audit_webhook
[5].notify = Control plane | Restart apiserver
[6].name = Write api audit webhook config yaml
[6].template.src = apiserver-audit-webhook-config.yaml.j2
[6].template.dest = {{ audit_webhook_config_file }}
[6].template.mode = 0640
[6].when = kubernetes_audit_webhook
[6].notify = Control plane | Restart apiserver
[7].name = Create apiserver tracing config directory
[7].file.path = {{ kube_config_dir }}/tracing
[7].file.state = directory
[7].file.mode = 0640
[7].when = kube_apiserver_tracing
[8].name = Write apiserver tracing config yaml
[8].template.src = apiserver-tracing.yaml.j2
[8].template.dest = {{ kube_config_dir }}/tracing/apiserver-tracing.yaml
[8].template.mode = 0640
[8].when = kube_apiserver_tracing
[8].notify = Control plane | Restart apiserver
[9].name = Set kubeadm_config_api_fqdn define
[9].set_fact.kubeadm_config_api_fqdn = {{ apiserver_loadbalancer_domain_name }}
[9].when = loadbalancer_apiserver is defined
[10].name = Kubeadm | Create kubeadm config
[10].template.src = kubeadm-config.{{ kubeadm_config_api_version }}.yaml.j2
[10].template.dest = {{ kube_config_dir }}/kubeadm-config.yaml
[10].template.mode = 0640
[10].template.validate = {{ kubeadm_config_validate_enabled | ternary(bin_dir + '/kubeadm config validate --config %s', omit) }}
[11].name = Kubeadm | Create directory to store admission control configurations
[11].file.path = {{ kube_config_dir }}/admission-controls
[11].file.state = directory
[11].file.mode = 0640
[11].when = kube_apiserver_admission_control_config_file
[12].name = Kubeadm | Push admission control config file
[12].template.src = admission-controls.yaml.j2
[12].template.dest = {{ kube_config_dir }}/admission-controls/admission-controls.yaml
[12].template.mode = 0640
[12].when = kube_apiserver_admission_control_config_file
[12].notify = Control plane | Restart apiserver
[13].name = Kubeadm | Push admission control config files
[13].template.src = {{ item | lower }}.yaml.j2
[13].template.dest = {{ kube_config_dir }}/admission-controls/{{ item | lower }}.yaml
[13].template.mode = 0640
[13].when[0] = kube_apiserver_admission_control_config_file
[13].when[1] = item in kube_apiserver_admission_plugins_needs_configuration
[13].loop = {{ kube_apiserver_enable_admission_plugins }}
[13].notify = Control plane | Restart apiserver
[14].name = Kubeadm | Check apiserver.crt SANs
[14].vars.apiserver_ips = {{ apiserver_sans | map('ansible.utils.ipaddr') | reject('equalto', False) | list }}
[14].vars.apiserver_hosts = {{ apiserver_sans | difference(apiserver_ips) }}
[14].when[0] = kubeadm_already_run.stat.exists
[14].when[1] = not kube_external_ca_mode
[14].block[0].name = Kubeadm | Check apiserver.crt SAN IPs
[14].block[0].command.cmd = openssl x509 -noout -in {{ kube_cert_dir }}/apiserver.crt -checkip {{ item }}
[14].block[0].loop = {{ apiserver_ips }}
[14].block[0].register = apiserver_sans_ip_check
[14].block[0].changed_when = apiserver_sans_ip_check.stdout is not search('does match certificate')
[14].block[0].failed_when = apiserver_sans_ip_check.rc != 0 and apiserver_sans_ip_check.stdout is not search('does NOT match certificate')
[14].block[1].name = Kubeadm | Check apiserver.crt SAN hosts
[14].block[1].command.cmd = openssl x509 -noout -in {{ kube_cert_dir }}/apiserver.crt -checkhost {{ item }}
[14].block[1].loop = {{ apiserver_hosts }}
[14].block[1].register = apiserver_sans_host_check
[14].block[1].changed_when = apiserver_sans_host_check.stdout is not search('does match certificate')
[14].block[1].failed_when = apiserver_sans_host_check.rc != 0 and apiserver_sans_host_check.stdout is not search('does NOT match certificate')
[15].name = Kubeadm | regenerate apiserver cert 1/2
[15].file.state = absent
[15].file.path = {{ kube_cert_dir }}/{{ item }}
[15].with_items[0] = apiserver.crt
[15].with_items[1] = apiserver.key
[15].when[0] = kubeadm_already_run.stat.exists
[15].when[1] = apiserver_sans_ip_check.changed or apiserver_sans_host_check.changed
[15].when[2] = not kube_external_ca_mode
[16].name = Kubeadm | regenerate apiserver cert 2/2
[16].command = {{ bin_dir }}/kubeadm init phase certs apiserver --config={{ kube_config_dir }}/kubeadm-config.yaml
[16].when[0] = kubeadm_already_run.stat.exists
[16].when[1] = apiserver_sans_ip_check.changed or apiserver_sans_host_check.changed
[16].when[2] = not kube_external_ca_mode
[17].name = Kubeadm | Initialize first control plane node
[17].when = inventory_hostname == first_kube_control_plane and not kubeadm_already_run.stat.exists
[17].vars.kubeadm_init_first_control_plane_cmd = timeout -k {{ kubeadm_init_timeout }} {{ kubeadm_init_timeout }} {{ bin_dir }}/kubeadm init --config={{ kube_config_dir }}/kubeadm-config.yaml --ignore-preflight-errors={{ _ignore_errors | flatten | join(',') }} --skip-phases={{ kubeadm_init_phases_skip | join(',') }} {{ kube_external_ca_mode | ternary('', '--upload-certs') }}
[17].vars._ignore_errors = {{ kubeadm_ignore_preflight_errors }}
[17].environment.PATH = {{ bin_dir }}:{{ ansible_env.PATH }}
[17].notify = Control plane | restart kubelet
[17].block[0].name = Kubeadm | Initialize first control plane node (1st try)
[17].block[0].command = {{ kubeadm_init_first_control_plane_cmd }}
[17].block[0].register = kubeadm_init
[17].block[0].failed_when = kubeadm_init.rc != 0 and "field is immutable" not in kubeadm_init.stderr
[17].rescue[0].name = Kubeadm | Initialize first control plane node (retry)
[17].rescue[0].command = {{ kubeadm_init_first_control_plane_cmd }}
[17].rescue[0].vars._errors_from_first_try[0] = FileAvailable--etc-kubernetes-manifests-kube-controller-manager.yaml
[17].rescue[0].vars._errors_from_first_try[1] = FileAvailable--etc-kubernetes-manifests-kube-scheduler.yaml
[17].rescue[0].vars._errors_from_first_try[2] = FileAvailable--etc-kubernetes-manifests-kube-apiserver.yaml
[17].rescue[0].vars._errors_from_first_try[3] = Port-10250
[17].rescue[0].vars._ignore_errors[0] = {{ kubeadm_ignore_preflight_errors }}
[17].rescue[0].vars._ignore_errors[1] = {{ _errors_from_first_try if 'all' not in kubeadm_ignore_preflight_errors else [] }}
[17].rescue[0].register = kubeadm_init
[17].rescue[0].retries = 2
[17].rescue[0].until = kubeadm_init is succeeded or "field is immutable" in kubeadm_init.stderr
[17].rescue[0].failed_when = kubeadm_init.rc != 0 and "field is immutable" not in kubeadm_init.stderr
[18].name = Set kubeadm certificate key
[18].set_fact.kubeadm_certificate_key = {{ item | regex_search('--certificate-key ([^ ]+)', '\\1') | first }}
[18].with_items = {{ hostvars[groups['kube_control_plane'][0]]['kubeadm_init'].stdout_lines | default([]) }}
[18].when[0] = kubeadm_certificate_key is not defined
[18].when[1] = (item | trim) is match('.*--certificate-key.*')
[19].name = Create hardcoded kubeadm token for joining nodes with 24h expiration (if defined)
[19].shell = {{ bin_dir }}/kubeadm --kubeconfig {{ kube_config_dir }}/admin.conf token delete {{ kubeadm_token }} || :; {{ bin_dir }}/kubeadm --kubeconfig {{ kube_config_dir }}/admin.conf token create {{ kubeadm_token }}
[19].changed_when = false
[19].when[0] = inventory_hostname == first_kube_control_plane
[19].when[1] = kubeadm_token is defined
[19].when[2] = kubeadm_refresh_token
[19].tags[0] = kubeadm_token
[20].name = Remove binding to anonymous user
[20].command = {{ kubectl }} -n kube-public delete rolebinding kubeadm:bootstrap-signer-clusterinfo --ignore-not-found
[20].when = inventory_hostname == first_kube_control_plane and remove_anonymous_access
[21].name = Create kubeadm token for joining nodes with 24h expiration (default)
[21].command = {{ bin_dir }}/kubeadm --kubeconfig {{ kube_config_dir }}/admin.conf token create
[21].changed_when = false
[21].register = temp_token
[21].retries = 5
[21].delay = 5
[21].until = temp_token is succeeded
[21].delegate_to = {{ first_kube_control_plane }}
[21].when = kubeadm_token is not defined
[21].tags[0] = kubeadm_token
[22].name = Set kubeadm_token
[22].set_fact.kubeadm_token = {{ temp_token.stdout }}
[22].when = temp_token.stdout is defined
[22].tags[0] = kubeadm_token
[23].name = Kubeadm | Join other control plane nodes
[23].include_tasks = kubeadm-secondary.yml
[24].name = Kubeadm | upgrade kubernetes cluster to {{ kube_version }}
[24].include_tasks = kubeadm-upgrade.yml
[24].when[0] = upgrade_cluster_setup
[24].when[1] = kubeadm_already_run.stat.exists
[25].name = Kubeadm | Remove taint for control plane node with node role
[25].command = {{ kubectl }} taint node {{ inventory_hostname }} {{ item }}
[25].delegate_to = {{ first_kube_control_plane }}
[25].with_items[0] = node-role.kubernetes.io/control-plane:NoSchedule-
[25].when = ('kube_node' in group_names)
[25].failed_when = false
